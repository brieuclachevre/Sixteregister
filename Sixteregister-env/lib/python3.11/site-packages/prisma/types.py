# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _TeamStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.TeamStatus']]


class _TeamStatusListFilterHasInput(TypedDict):
    has: 'enums.TeamStatus'


class _TeamStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.TeamStatus']


class _TeamStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.TeamStatus']


class _TeamStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


TeamStatusListFilter = Union[
    _TeamStatusListFilterHasInput,
    _TeamStatusListFilterEqualsInput,
    _TeamStatusListFilterHasSomeInput,
    _TeamStatusListFilterIsEmptyInput,
    _TeamStatusListFilterHasEveryInput,
]


class _TeamStatusListUpdateSet(TypedDict):
    set: List['enums.TeamStatus']


class _TeamStatusListUpdatePush(TypedDict):
    push: List['enums.TeamStatus']


TeamStatusListUpdate = Union[
    List['enums.TeamStatus'],
    _TeamStatusListUpdateSet,
    _TeamStatusListUpdatePush,
]

class _EnumUserStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.EnumUserStatus']]


class _EnumUserStatusListFilterHasInput(TypedDict):
    has: 'enums.EnumUserStatus'


class _EnumUserStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.EnumUserStatus']


class _EnumUserStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.EnumUserStatus']


class _EnumUserStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


EnumUserStatusListFilter = Union[
    _EnumUserStatusListFilterHasInput,
    _EnumUserStatusListFilterEqualsInput,
    _EnumUserStatusListFilterHasSomeInput,
    _EnumUserStatusListFilterIsEmptyInput,
    _EnumUserStatusListFilterHasEveryInput,
]


class _EnumUserStatusListUpdateSet(TypedDict):
    set: List['enums.EnumUserStatus']


class _EnumUserStatusListUpdatePush(TypedDict):
    push: List['enums.EnumUserStatus']


EnumUserStatusListUpdate = Union[
    List['enums.EnumUserStatus'],
    _EnumUserStatusListUpdateSet,
    _EnumUserStatusListUpdatePush,
]

class _GenderListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Gender']]


class _GenderListFilterHasInput(TypedDict):
    has: 'enums.Gender'


class _GenderListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Gender']


class _GenderListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Gender']


class _GenderListFilterIsEmptyInput(TypedDict):
    is_empty: bool


GenderListFilter = Union[
    _GenderListFilterHasInput,
    _GenderListFilterEqualsInput,
    _GenderListFilterHasSomeInput,
    _GenderListFilterIsEmptyInput,
    _GenderListFilterHasEveryInput,
]


class _GenderListUpdateSet(TypedDict):
    set: List['enums.Gender']


class _GenderListUpdatePush(TypedDict):
    push: List['enums.Gender']


GenderListUpdate = Union[
    List['enums.Gender'],
    _GenderListUpdateSet,
    _GenderListUpdatePush,
]

class _mailClientListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.mailClient']]


class _mailClientListFilterHasInput(TypedDict):
    has: 'enums.mailClient'


class _mailClientListFilterHasEveryInput(TypedDict):
    has_every: List['enums.mailClient']


class _mailClientListFilterHasSomeInput(TypedDict):
    has_some: List['enums.mailClient']


class _mailClientListFilterIsEmptyInput(TypedDict):
    is_empty: bool


mailClientListFilter = Union[
    _mailClientListFilterHasInput,
    _mailClientListFilterEqualsInput,
    _mailClientListFilterHasSomeInput,
    _mailClientListFilterIsEmptyInput,
    _mailClientListFilterHasEveryInput,
]


class _mailClientListUpdateSet(TypedDict):
    set: List['enums.mailClient']


class _mailClientListUpdatePush(TypedDict):
    push: List['enums.mailClient']


mailClientListUpdate = Union[
    List['enums.mailClient'],
    _mailClientListUpdateSet,
    _mailClientListUpdatePush,
]

class _PaymentStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.PaymentStatus']]


class _PaymentStatusListFilterHasInput(TypedDict):
    has: 'enums.PaymentStatus'


class _PaymentStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.PaymentStatus']


class _PaymentStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.PaymentStatus']


class _PaymentStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


PaymentStatusListFilter = Union[
    _PaymentStatusListFilterHasInput,
    _PaymentStatusListFilterEqualsInput,
    _PaymentStatusListFilterHasSomeInput,
    _PaymentStatusListFilterIsEmptyInput,
    _PaymentStatusListFilterHasEveryInput,
]


class _PaymentStatusListUpdateSet(TypedDict):
    set: List['enums.PaymentStatus']


class _PaymentStatusListUpdatePush(TypedDict):
    push: List['enums.PaymentStatus']


PaymentStatusListUpdate = Union[
    List['enums.PaymentStatus'],
    _PaymentStatusListUpdateSet,
    _PaymentStatusListUpdatePush,
]


# Sport types

class SportOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Sport create method"""
    id: _int
    teams: 'TeamCreateManyNestedWithoutRelationsInput'
    nbPlayersMin: _int
    nbPlayersMax: _int
    isCollective: _bool
    nbOfTeams: _int
    admins: 'UserCreateManyNestedWithoutRelationsInput'


class SportCreateInput(SportOptionalCreateInput):
    """Required arguments to the Sport create method"""
    sport: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SportOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Sport create method, without relations"""
    id: _int
    nbPlayersMin: _int
    nbPlayersMax: _int
    isCollective: _bool
    nbOfTeams: _int


class SportCreateWithoutRelationsInput(SportOptionalCreateWithoutRelationsInput):
    """Required arguments to the Sport create method, without relations"""
    sport: _str


class SportCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SportCreateWithoutRelationsInput'
    connect: 'SportWhereUniqueInput'


class SportCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SportCreateWithoutRelationsInput', List['SportCreateWithoutRelationsInput']]
    connect: Union['SportWhereUniqueInput', List['SportWhereUniqueInput']]


_SportWhereUnique_id_Input = TypedDict(
    '_SportWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

SportWhereUniqueInput = _SportWhereUnique_id_Input


class SportUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    sport: _str
    teams: 'TeamUpdateManyWithoutRelationsInput'
    nbPlayersMin: Union[AtomicIntInput, _int]
    nbPlayersMax: Union[AtomicIntInput, _int]
    isCollective: _bool
    nbOfTeams: Union[AtomicIntInput, _int]
    admins: 'UserUpdateManyWithoutRelationsInput'


class SportUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    sport: _str
    nbPlayersMin: Union[AtomicIntInput, _int]
    nbPlayersMax: Union[AtomicIntInput, _int]
    isCollective: _bool
    nbOfTeams: Union[AtomicIntInput, _int]


class SportUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SportCreateWithoutRelationsInput']
    connect: List['SportWhereUniqueInput']
    set: List['SportWhereUniqueInput']
    disconnect: List['SportWhereUniqueInput']
    delete: List['SportWhereUniqueInput']

    # TODO
    # update: List['SportUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SportUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SportScalarWhereInput']
    # upsert: List['SportUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SportCreateOrConnectWithoutRelationsInput']


class SportUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SportCreateWithoutRelationsInput'
    connect: 'SportWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SportUpdateInput'
    # upsert: 'SportUpsertWithoutRelationsInput'
    # connectOrCreate: 'SportCreateOrConnectWithoutRelationsInput'


class SportUpsertInput(TypedDict):
    create: 'SportCreateInput'
    update: 'SportUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Sport_id_OrderByInput = TypedDict(
    '_Sport_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Sport_sport_OrderByInput = TypedDict(
    '_Sport_sport_OrderByInput',
    {
        'sport': 'SortOrder',
    },
    total=True
)

_Sport_nbPlayersMin_OrderByInput = TypedDict(
    '_Sport_nbPlayersMin_OrderByInput',
    {
        'nbPlayersMin': 'SortOrder',
    },
    total=True
)

_Sport_nbPlayersMax_OrderByInput = TypedDict(
    '_Sport_nbPlayersMax_OrderByInput',
    {
        'nbPlayersMax': 'SortOrder',
    },
    total=True
)

_Sport_isCollective_OrderByInput = TypedDict(
    '_Sport_isCollective_OrderByInput',
    {
        'isCollective': 'SortOrder',
    },
    total=True
)

_Sport_nbOfTeams_OrderByInput = TypedDict(
    '_Sport_nbOfTeams_OrderByInput',
    {
        'nbOfTeams': 'SortOrder',
    },
    total=True
)

SportOrderByInput = Union[
    '_Sport_id_OrderByInput',
    '_Sport_sport_OrderByInput',
    '_Sport_nbPlayersMin_OrderByInput',
    '_Sport_nbPlayersMax_OrderByInput',
    '_Sport_isCollective_OrderByInput',
    '_Sport_nbOfTeams_OrderByInput',
]



# recursive Sport types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SportRelationFilter = TypedDict(
    'SportRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SportListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SportInclude(TypedDict, total=False):
    """Sport relational arguments"""
    teams: Union[bool, 'FindManyTeamArgsFromSport']
    admins: Union[bool, 'FindManyUserArgsFromSport']


    

class SportIncludeFromSport(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive1']
    admins: Union[bool, 'FindManyUserArgsFromSportRecursive1']


class SportIncludeFromSportRecursive1(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive2']
    admins: Union[bool, 'FindManyUserArgsFromSportRecursive2']


class SportIncludeFromSportRecursive2(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive3']
    admins: Union[bool, 'FindManyUserArgsFromSportRecursive3']


class SportIncludeFromSportRecursive3(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive4']
    admins: Union[bool, 'FindManyUserArgsFromSportRecursive4']


class SportIncludeFromSportRecursive4(TypedDict, total=False):
    """Relational arguments for Sport"""

    

class SportArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SportIncludeFromSportRecursive1'


class SportArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SportIncludeFromSportRecursive2'


class SportArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SportIncludeFromSportRecursive3'


class SportArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SportIncludeFromSportRecursive4'


class SportArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    
    

class FindManySportArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive1'


class FindManySportArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive2'


class FindManySportArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive3'


class FindManySportArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive4'


class FindManySportArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    
    

class TeamIncludeFromSport(TypedDict, total=False):
    """Relational arguments for Sport"""
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive1']
    sport: Union[bool, 'SportArgsFromSportRecursive1']
    admin: Union[bool, 'UserArgsFromSportRecursive1']
    school: Union[bool, 'SchoolArgsFromSportRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive1']


class TeamIncludeFromSportRecursive1(TypedDict, total=False):
    """Relational arguments for Sport"""
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive2']
    sport: Union[bool, 'SportArgsFromSportRecursive2']
    admin: Union[bool, 'UserArgsFromSportRecursive2']
    school: Union[bool, 'SchoolArgsFromSportRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive2']


class TeamIncludeFromSportRecursive2(TypedDict, total=False):
    """Relational arguments for Sport"""
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive3']
    sport: Union[bool, 'SportArgsFromSportRecursive3']
    admin: Union[bool, 'UserArgsFromSportRecursive3']
    school: Union[bool, 'SchoolArgsFromSportRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive3']


class TeamIncludeFromSportRecursive3(TypedDict, total=False):
    """Relational arguments for Sport"""
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive4']
    sport: Union[bool, 'SportArgsFromSportRecursive4']
    admin: Union[bool, 'UserArgsFromSportRecursive4']
    school: Union[bool, 'SchoolArgsFromSportRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive4']


class TeamIncludeFromSportRecursive4(TypedDict, total=False):
    """Relational arguments for Sport"""

    

class TeamArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    
    

class FindManyTeamArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class UserIncludeFromSport(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive1']
    school: Union[bool, 'SchoolArgsFromSportRecursive1']
    sportAdmin: Union[bool, 'SportArgsFromSportRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive1']


class UserIncludeFromSportRecursive1(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive2']
    school: Union[bool, 'SchoolArgsFromSportRecursive2']
    sportAdmin: Union[bool, 'SportArgsFromSportRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive2']


class UserIncludeFromSportRecursive2(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive3']
    school: Union[bool, 'SchoolArgsFromSportRecursive3']
    sportAdmin: Union[bool, 'SportArgsFromSportRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive3']


class UserIncludeFromSportRecursive3(TypedDict, total=False):
    """Relational arguments for Sport"""
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive4']
    school: Union[bool, 'SchoolArgsFromSportRecursive4']
    sportAdmin: Union[bool, 'SportArgsFromSportRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromSportRecursive4']


class UserIncludeFromSportRecursive4(TypedDict, total=False):
    """Relational arguments for Sport"""

    

class UserArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    
    

class FindManyUserArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ParticipantIncludeFromSport(TypedDict, total=False):
    """Relational arguments for Sport"""
    school: Union[bool, 'SchoolArgsFromSportRecursive1']
    team: Union[bool, 'TeamArgsFromSportRecursive1']


class ParticipantIncludeFromSportRecursive1(TypedDict, total=False):
    """Relational arguments for Sport"""
    school: Union[bool, 'SchoolArgsFromSportRecursive2']
    team: Union[bool, 'TeamArgsFromSportRecursive2']


class ParticipantIncludeFromSportRecursive2(TypedDict, total=False):
    """Relational arguments for Sport"""
    school: Union[bool, 'SchoolArgsFromSportRecursive3']
    team: Union[bool, 'TeamArgsFromSportRecursive3']


class ParticipantIncludeFromSportRecursive3(TypedDict, total=False):
    """Relational arguments for Sport"""
    school: Union[bool, 'SchoolArgsFromSportRecursive4']
    team: Union[bool, 'TeamArgsFromSportRecursive4']


class ParticipantIncludeFromSportRecursive4(TypedDict, total=False):
    """Relational arguments for Sport"""

    

class ParticipantArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    
    

class FindManyParticipantArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class SchoolIncludeFromSport(TypedDict, total=False):
    """Relational arguments for Sport"""
    users: Union[bool, 'FindManyUserArgsFromSportRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive1']


class SchoolIncludeFromSportRecursive1(TypedDict, total=False):
    """Relational arguments for Sport"""
    users: Union[bool, 'FindManyUserArgsFromSportRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive2']


class SchoolIncludeFromSportRecursive2(TypedDict, total=False):
    """Relational arguments for Sport"""
    users: Union[bool, 'FindManyUserArgsFromSportRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive3']


class SchoolIncludeFromSportRecursive3(TypedDict, total=False):
    """Relational arguments for Sport"""
    users: Union[bool, 'FindManyUserArgsFromSportRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromSportRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromSportRecursive4']


class SchoolIncludeFromSportRecursive4(TypedDict, total=False):
    """Relational arguments for Sport"""

    

class SchoolArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SchoolIncludeFromSchoolRecursive1'


class SchoolArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SchoolIncludeFromSchoolRecursive2'


class SchoolArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SchoolIncludeFromSchoolRecursive3'


class SchoolArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'SchoolIncludeFromSchoolRecursive4'


class SchoolArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    
    

class FindManySchoolArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive1'


class FindManySchoolArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive2'


class FindManySchoolArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive3'


class FindManySchoolArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive4'


class FindManySchoolArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    
    

class GeneralConfigIncludeFromSport(TypedDict, total=False):
    """Relational arguments for Sport"""


class GeneralConfigIncludeFromSportRecursive1(TypedDict, total=False):
    """Relational arguments for Sport"""


class GeneralConfigIncludeFromSportRecursive2(TypedDict, total=False):
    """Relational arguments for Sport"""


class GeneralConfigIncludeFromSportRecursive3(TypedDict, total=False):
    """Relational arguments for Sport"""


class GeneralConfigIncludeFromSportRecursive4(TypedDict, total=False):
    """Relational arguments for Sport"""

    

class GeneralConfigArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class GeneralConfigArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class GeneralConfigArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class GeneralConfigArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class GeneralConfigArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    
    

class FindManyGeneralConfigArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class FindManyGeneralConfigArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class FindManyGeneralConfigArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class FindManyGeneralConfigArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class FindManyGeneralConfigArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    
    

class PaymentIncludeFromSport(TypedDict, total=False):
    """Relational arguments for Sport"""
    user: Union[bool, 'UserArgsFromSportRecursive1']
    team: Union[bool, 'TeamArgsFromSportRecursive1']


class PaymentIncludeFromSportRecursive1(TypedDict, total=False):
    """Relational arguments for Sport"""
    user: Union[bool, 'UserArgsFromSportRecursive2']
    team: Union[bool, 'TeamArgsFromSportRecursive2']


class PaymentIncludeFromSportRecursive2(TypedDict, total=False):
    """Relational arguments for Sport"""
    user: Union[bool, 'UserArgsFromSportRecursive3']
    team: Union[bool, 'TeamArgsFromSportRecursive3']


class PaymentIncludeFromSportRecursive3(TypedDict, total=False):
    """Relational arguments for Sport"""
    user: Union[bool, 'UserArgsFromSportRecursive4']
    team: Union[bool, 'TeamArgsFromSportRecursive4']


class PaymentIncludeFromSportRecursive4(TypedDict, total=False):
    """Relational arguments for Sport"""

    

class PaymentArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'PaymentIncludeFromPaymentRecursive1'


class PaymentArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'PaymentIncludeFromPaymentRecursive2'


class PaymentArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'PaymentIncludeFromPaymentRecursive3'


class PaymentArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    include: 'PaymentIncludeFromPaymentRecursive4'


class PaymentArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    
    

class FindManyPaymentArgsFromSport(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive1'


class FindManyPaymentArgsFromSportRecursive1(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive2'


class FindManyPaymentArgsFromSportRecursive2(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive3'


class FindManyPaymentArgsFromSportRecursive3(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive4'


class FindManyPaymentArgsFromSportRecursive4(TypedDict, total=False):
    """Arguments for Sport"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    


FindManySportArgs = FindManySportArgsFromSport
FindFirstSportArgs = FindManySportArgsFromSport


    

class SportWhereInput(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    sport: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    nbPlayersMin: Union[_int, 'types.IntFilter']
    nbPlayersMax: Union[_int, 'types.IntFilter']
    isCollective: Union[_bool, 'types.BooleanFilter']
    nbOfTeams: Union[_int, 'types.IntFilter']
    admins: 'UserListRelationFilter'

    # should be noted that AND and NOT should be Union['SportWhereInputRecursive1', List['SportWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SportWhereInputRecursive1']
    OR: List['SportWhereInputRecursive1']
    NOT: List['SportWhereInputRecursive1']


class SportWhereInputRecursive1(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    sport: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    nbPlayersMin: Union[_int, 'types.IntFilter']
    nbPlayersMax: Union[_int, 'types.IntFilter']
    isCollective: Union[_bool, 'types.BooleanFilter']
    nbOfTeams: Union[_int, 'types.IntFilter']
    admins: 'UserListRelationFilter'

    # should be noted that AND and NOT should be Union['SportWhereInputRecursive2', List['SportWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SportWhereInputRecursive2']
    OR: List['SportWhereInputRecursive2']
    NOT: List['SportWhereInputRecursive2']


class SportWhereInputRecursive2(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    sport: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    nbPlayersMin: Union[_int, 'types.IntFilter']
    nbPlayersMax: Union[_int, 'types.IntFilter']
    isCollective: Union[_bool, 'types.BooleanFilter']
    nbOfTeams: Union[_int, 'types.IntFilter']
    admins: 'UserListRelationFilter'

    # should be noted that AND and NOT should be Union['SportWhereInputRecursive3', List['SportWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SportWhereInputRecursive3']
    OR: List['SportWhereInputRecursive3']
    NOT: List['SportWhereInputRecursive3']


class SportWhereInputRecursive3(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    sport: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    nbPlayersMin: Union[_int, 'types.IntFilter']
    nbPlayersMax: Union[_int, 'types.IntFilter']
    isCollective: Union[_bool, 'types.BooleanFilter']
    nbOfTeams: Union[_int, 'types.IntFilter']
    admins: 'UserListRelationFilter'

    # should be noted that AND and NOT should be Union['SportWhereInputRecursive4', List['SportWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SportWhereInputRecursive4']
    OR: List['SportWhereInputRecursive4']
    NOT: List['SportWhereInputRecursive4']


class SportWhereInputRecursive4(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    sport: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    nbPlayersMin: Union[_int, 'types.IntFilter']
    nbPlayersMax: Union[_int, 'types.IntFilter']
    isCollective: Union[_bool, 'types.BooleanFilter']
    nbOfTeams: Union[_int, 'types.IntFilter']
    admins: 'UserListRelationFilter'



# aggregate Sport types


    

class SportScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    sport: Union[_str, 'types.StringWithAggregatesFilter']
    nbPlayersMin: Union[_int, 'types.IntWithAggregatesFilter']
    nbPlayersMax: Union[_int, 'types.IntWithAggregatesFilter']
    isCollective: Union[_bool, 'types.BooleanWithAggregatesFilter']
    nbOfTeams: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['SportScalarWhereWithAggregatesInputRecursive1']
    OR: List['SportScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SportScalarWhereWithAggregatesInputRecursive1']


class SportScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    sport: Union[_str, 'types.StringWithAggregatesFilter']
    nbPlayersMin: Union[_int, 'types.IntWithAggregatesFilter']
    nbPlayersMax: Union[_int, 'types.IntWithAggregatesFilter']
    isCollective: Union[_bool, 'types.BooleanWithAggregatesFilter']
    nbOfTeams: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['SportScalarWhereWithAggregatesInputRecursive2']
    OR: List['SportScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SportScalarWhereWithAggregatesInputRecursive2']


class SportScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    sport: Union[_str, 'types.StringWithAggregatesFilter']
    nbPlayersMin: Union[_int, 'types.IntWithAggregatesFilter']
    nbPlayersMax: Union[_int, 'types.IntWithAggregatesFilter']
    isCollective: Union[_bool, 'types.BooleanWithAggregatesFilter']
    nbOfTeams: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['SportScalarWhereWithAggregatesInputRecursive3']
    OR: List['SportScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SportScalarWhereWithAggregatesInputRecursive3']


class SportScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    sport: Union[_str, 'types.StringWithAggregatesFilter']
    nbPlayersMin: Union[_int, 'types.IntWithAggregatesFilter']
    nbPlayersMax: Union[_int, 'types.IntWithAggregatesFilter']
    isCollective: Union[_bool, 'types.BooleanWithAggregatesFilter']
    nbOfTeams: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['SportScalarWhereWithAggregatesInputRecursive4']
    OR: List['SportScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SportScalarWhereWithAggregatesInputRecursive4']


class SportScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Sport arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    sport: Union[_str, 'types.StringWithAggregatesFilter']
    nbPlayersMin: Union[_int, 'types.IntWithAggregatesFilter']
    nbPlayersMax: Union[_int, 'types.IntWithAggregatesFilter']
    isCollective: Union[_bool, 'types.BooleanWithAggregatesFilter']
    nbOfTeams: Union[_int, 'types.IntWithAggregatesFilter']



class SportGroupByOutput(TypedDict, total=False):
    id: _int
    sport: _str
    nbPlayersMin: _int
    nbPlayersMax: _int
    isCollective: _bool
    nbOfTeams: _int
    _sum: 'SportSumAggregateOutput'
    _avg: 'SportAvgAggregateOutput'
    _min: 'SportMinAggregateOutput'
    _max: 'SportMaxAggregateOutput'
    _count: 'SportCountAggregateOutput'


class SportAvgAggregateOutput(TypedDict, total=False):
    """Sport output for aggregating averages"""
    id: float
    nbPlayersMin: float
    nbPlayersMax: float
    nbOfTeams: float


class SportSumAggregateOutput(TypedDict, total=False):
    """Sport output for aggregating sums"""
    id: _int
    nbPlayersMin: _int
    nbPlayersMax: _int
    nbOfTeams: _int


class SportScalarAggregateOutput(TypedDict, total=False):
    """Sport output including scalar fields"""
    id: _int
    sport: _str
    nbPlayersMin: _int
    nbPlayersMax: _int
    isCollective: _bool
    nbOfTeams: _int


SportMinAggregateOutput = SportScalarAggregateOutput
SportMaxAggregateOutput = SportScalarAggregateOutput


class SportMaxAggregateInput(TypedDict, total=False):
    """Sport input for aggregating by max"""
    id: bool
    sport: bool
    nbPlayersMin: bool
    nbPlayersMax: bool
    isCollective: bool
    nbOfTeams: bool


class SportMinAggregateInput(TypedDict, total=False):
    """Sport input for aggregating by min"""
    id: bool
    sport: bool
    nbPlayersMin: bool
    nbPlayersMax: bool
    isCollective: bool
    nbOfTeams: bool


class SportNumberAggregateInput(TypedDict, total=False):
    """Sport input for aggregating numbers"""
    id: bool
    nbPlayersMin: bool
    nbPlayersMax: bool
    nbOfTeams: bool


SportAvgAggregateInput = SportNumberAggregateInput
SportSumAggregateInput = SportNumberAggregateInput


SportCountAggregateInput = TypedDict(
    'SportCountAggregateInput',
    {
        'id': bool,
        'sport': bool,
        'nbPlayersMin': bool,
        'nbPlayersMax': bool,
        'isCollective': bool,
        'nbOfTeams': bool,
        '_all': bool,
    },
    total=False,
)

SportCountAggregateOutput = TypedDict(
    'SportCountAggregateOutput',
    {
        'id': int,
        'sport': int,
        'nbPlayersMin': int,
        'nbPlayersMax': int,
        'isCollective': int,
        'nbOfTeams': int,
        '_all': int,
    },
    total=False,
)


SportKeys = Literal[
    'id',
    'sport',
    'teams',
    'nbPlayersMin',
    'nbPlayersMax',
    'isCollective',
    'nbOfTeams',
    'admins',
]
SportScalarFieldKeys = Literal[
    'id',
    'sport',
    'nbPlayersMin',
    'nbPlayersMax',
    'isCollective',
    'nbOfTeams',
]
SportScalarFieldKeysT = TypeVar('SportScalarFieldKeysT', bound=SportScalarFieldKeys)

SportRelationalFieldKeys = Literal[
        'teams',
        'admins',
    ]

# Team types

class TeamOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Team create method"""
    id: _int
    participants: 'ParticipantCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    sportId: _int
    sport: 'SportCreateNestedWithoutRelationsInput'
    teamAdminUserId: _int
    admin: 'UserCreateNestedWithoutRelationsInput'
    schoolId: _int
    school: 'SchoolCreateNestedWithoutRelationsInput'
    amountPaidInCents: _int
    amountToPayInCents: _int
    Payment: 'PaymentCreateManyNestedWithoutRelationsInput'


class TeamCreateInput(TeamOptionalCreateInput):
    """Required arguments to the Team create method"""
    name: _str
    status: 'enums.TeamStatus'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Team create method, without relations"""
    id: _int
    createdAt: datetime.datetime
    sportId: _int
    teamAdminUserId: _int
    schoolId: _int
    amountPaidInCents: _int
    amountToPayInCents: _int


class TeamCreateWithoutRelationsInput(TeamOptionalCreateWithoutRelationsInput):
    """Required arguments to the Team create method, without relations"""
    name: _str
    status: 'enums.TeamStatus'


class TeamCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'


class TeamCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamCreateWithoutRelationsInput', List['TeamCreateWithoutRelationsInput']]
    connect: Union['TeamWhereUniqueInput', List['TeamWhereUniqueInput']]


_TeamWhereUnique_id_Input = TypedDict(
    '_TeamWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

TeamWhereUniqueInput = _TeamWhereUnique_id_Input


class TeamUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    participants: 'ParticipantUpdateManyWithoutRelationsInput'
    status: 'enums.TeamStatus'
    createdAt: datetime.datetime
    sport: 'SportUpdateOneWithoutRelationsInput'
    admin: 'UserUpdateOneWithoutRelationsInput'
    school: 'SchoolUpdateOneWithoutRelationsInput'
    amountPaidInCents: Union[AtomicIntInput, _int]
    amountToPayInCents: Union[AtomicIntInput, _int]
    Payment: 'PaymentUpdateManyWithoutRelationsInput'


class TeamUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    status: 'enums.TeamStatus'
    createdAt: datetime.datetime
    amountPaidInCents: Union[AtomicIntInput, _int]
    amountToPayInCents: Union[AtomicIntInput, _int]


class TeamUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamCreateWithoutRelationsInput']
    connect: List['TeamWhereUniqueInput']
    set: List['TeamWhereUniqueInput']
    disconnect: List['TeamWhereUniqueInput']
    delete: List['TeamWhereUniqueInput']

    # TODO
    # update: List['TeamUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamScalarWhereInput']
    # upsert: List['TeamUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['TeamCreateOrConnectWithoutRelationsInput']


class TeamUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamUpdateInput'
    # upsert: 'TeamUpsertWithoutRelationsInput'
    # connectOrCreate: 'TeamCreateOrConnectWithoutRelationsInput'


class TeamUpsertInput(TypedDict):
    create: 'TeamCreateInput'
    update: 'TeamUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Team_id_OrderByInput = TypedDict(
    '_Team_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Team_name_OrderByInput = TypedDict(
    '_Team_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Team_status_OrderByInput = TypedDict(
    '_Team_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Team_createdAt_OrderByInput = TypedDict(
    '_Team_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Team_sportId_OrderByInput = TypedDict(
    '_Team_sportId_OrderByInput',
    {
        'sportId': 'SortOrder',
    },
    total=True
)

_Team_teamAdminUserId_OrderByInput = TypedDict(
    '_Team_teamAdminUserId_OrderByInput',
    {
        'teamAdminUserId': 'SortOrder',
    },
    total=True
)

_Team_schoolId_OrderByInput = TypedDict(
    '_Team_schoolId_OrderByInput',
    {
        'schoolId': 'SortOrder',
    },
    total=True
)

_Team_amountPaidInCents_OrderByInput = TypedDict(
    '_Team_amountPaidInCents_OrderByInput',
    {
        'amountPaidInCents': 'SortOrder',
    },
    total=True
)

_Team_amountToPayInCents_OrderByInput = TypedDict(
    '_Team_amountToPayInCents_OrderByInput',
    {
        'amountToPayInCents': 'SortOrder',
    },
    total=True
)

TeamOrderByInput = Union[
    '_Team_id_OrderByInput',
    '_Team_name_OrderByInput',
    '_Team_status_OrderByInput',
    '_Team_createdAt_OrderByInput',
    '_Team_sportId_OrderByInput',
    '_Team_teamAdminUserId_OrderByInput',
    '_Team_schoolId_OrderByInput',
    '_Team_amountPaidInCents_OrderByInput',
    '_Team_amountToPayInCents_OrderByInput',
]



# recursive Team types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TeamRelationFilter = TypedDict(
    'TeamRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TeamListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TeamInclude(TypedDict, total=False):
    """Team relational arguments"""
    participants: Union[bool, 'FindManyParticipantArgsFromTeam']
    sport: Union[bool, 'SportArgsFromTeam']
    admin: Union[bool, 'UserArgsFromTeam']
    school: Union[bool, 'SchoolArgsFromTeam']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeam']


    

class SportIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive1']
    admins: Union[bool, 'FindManyUserArgsFromTeamRecursive1']


class SportIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive2']
    admins: Union[bool, 'FindManyUserArgsFromTeamRecursive2']


class SportIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive3']
    admins: Union[bool, 'FindManyUserArgsFromTeamRecursive3']


class SportIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive4']
    admins: Union[bool, 'FindManyUserArgsFromTeamRecursive4']


class SportIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class SportArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SportIncludeFromSportRecursive1'


class SportArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SportIncludeFromSportRecursive2'


class SportArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SportIncludeFromSportRecursive3'


class SportArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SportIncludeFromSportRecursive4'


class SportArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManySportArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive1'


class FindManySportArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive2'


class FindManySportArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive3'


class FindManySportArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive4'


class FindManySportArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    
    

class TeamIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive1']
    sport: Union[bool, 'SportArgsFromTeamRecursive1']
    admin: Union[bool, 'UserArgsFromTeamRecursive1']
    school: Union[bool, 'SchoolArgsFromTeamRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive1']


class TeamIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive2']
    sport: Union[bool, 'SportArgsFromTeamRecursive2']
    admin: Union[bool, 'UserArgsFromTeamRecursive2']
    school: Union[bool, 'SchoolArgsFromTeamRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive2']


class TeamIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive3']
    sport: Union[bool, 'SportArgsFromTeamRecursive3']
    admin: Union[bool, 'UserArgsFromTeamRecursive3']
    school: Union[bool, 'SchoolArgsFromTeamRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive3']


class TeamIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive4']
    sport: Union[bool, 'SportArgsFromTeamRecursive4']
    admin: Union[bool, 'UserArgsFromTeamRecursive4']
    school: Union[bool, 'SchoolArgsFromTeamRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive4']


class TeamIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class TeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyTeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class UserIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive1']
    school: Union[bool, 'SchoolArgsFromTeamRecursive1']
    sportAdmin: Union[bool, 'SportArgsFromTeamRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive1']


class UserIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive2']
    school: Union[bool, 'SchoolArgsFromTeamRecursive2']
    sportAdmin: Union[bool, 'SportArgsFromTeamRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive2']


class UserIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive3']
    school: Union[bool, 'SchoolArgsFromTeamRecursive3']
    sportAdmin: Union[bool, 'SportArgsFromTeamRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive3']


class UserIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive4']
    school: Union[bool, 'SchoolArgsFromTeamRecursive4']
    sportAdmin: Union[bool, 'SportArgsFromTeamRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromTeamRecursive4']


class UserIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class UserArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyUserArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ParticipantIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    school: Union[bool, 'SchoolArgsFromTeamRecursive1']
    team: Union[bool, 'TeamArgsFromTeamRecursive1']


class ParticipantIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    school: Union[bool, 'SchoolArgsFromTeamRecursive2']
    team: Union[bool, 'TeamArgsFromTeamRecursive2']


class ParticipantIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    school: Union[bool, 'SchoolArgsFromTeamRecursive3']
    team: Union[bool, 'TeamArgsFromTeamRecursive3']


class ParticipantIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    school: Union[bool, 'SchoolArgsFromTeamRecursive4']
    team: Union[bool, 'TeamArgsFromTeamRecursive4']


class ParticipantIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class ParticipantArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyParticipantArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class SchoolIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    users: Union[bool, 'FindManyUserArgsFromTeamRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive1']


class SchoolIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    users: Union[bool, 'FindManyUserArgsFromTeamRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive2']


class SchoolIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    users: Union[bool, 'FindManyUserArgsFromTeamRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive3']


class SchoolIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    users: Union[bool, 'FindManyUserArgsFromTeamRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive4']


class SchoolIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class SchoolArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SchoolIncludeFromSchoolRecursive1'


class SchoolArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SchoolIncludeFromSchoolRecursive2'


class SchoolArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SchoolIncludeFromSchoolRecursive3'


class SchoolArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'SchoolIncludeFromSchoolRecursive4'


class SchoolArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManySchoolArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive1'


class FindManySchoolArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive2'


class FindManySchoolArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive3'


class FindManySchoolArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive4'


class FindManySchoolArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    
    

class GeneralConfigIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""


class GeneralConfigIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""


class GeneralConfigIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""


class GeneralConfigIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""


class GeneralConfigIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class GeneralConfigArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class GeneralConfigArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class GeneralConfigArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class GeneralConfigArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class GeneralConfigArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyGeneralConfigArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class FindManyGeneralConfigArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class FindManyGeneralConfigArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class FindManyGeneralConfigArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class FindManyGeneralConfigArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    
    

class PaymentIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeamRecursive1']
    team: Union[bool, 'TeamArgsFromTeamRecursive1']


class PaymentIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeamRecursive2']
    team: Union[bool, 'TeamArgsFromTeamRecursive2']


class PaymentIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeamRecursive3']
    team: Union[bool, 'TeamArgsFromTeamRecursive3']


class PaymentIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    user: Union[bool, 'UserArgsFromTeamRecursive4']
    team: Union[bool, 'TeamArgsFromTeamRecursive4']


class PaymentIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class PaymentArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PaymentIncludeFromPaymentRecursive1'


class PaymentArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PaymentIncludeFromPaymentRecursive2'


class PaymentArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PaymentIncludeFromPaymentRecursive3'


class PaymentArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'PaymentIncludeFromPaymentRecursive4'


class PaymentArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyPaymentArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive1'


class FindManyPaymentArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive2'


class FindManyPaymentArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive3'


class FindManyPaymentArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive4'


class FindManyPaymentArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    


FindManyTeamArgs = FindManyTeamArgsFromTeam
FindFirstTeamArgs = FindManyTeamArgsFromTeam


    

class TeamWhereInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    participants: 'ParticipantListRelationFilter'
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    sportId: Union[_int, 'types.IntFilter']
    sport: 'SportRelationFilter'
    teamAdminUserId: Union[_int, 'types.IntFilter']
    admin: 'UserRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    amountPaidInCents: Union[_int, 'types.IntFilter']
    amountToPayInCents: Union[_int, 'types.IntFilter']
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive1', List['TeamWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive1']
    OR: List['TeamWhereInputRecursive1']
    NOT: List['TeamWhereInputRecursive1']


class TeamWhereInputRecursive1(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    participants: 'ParticipantListRelationFilter'
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    sportId: Union[_int, 'types.IntFilter']
    sport: 'SportRelationFilter'
    teamAdminUserId: Union[_int, 'types.IntFilter']
    admin: 'UserRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    amountPaidInCents: Union[_int, 'types.IntFilter']
    amountToPayInCents: Union[_int, 'types.IntFilter']
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive2', List['TeamWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive2']
    OR: List['TeamWhereInputRecursive2']
    NOT: List['TeamWhereInputRecursive2']


class TeamWhereInputRecursive2(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    participants: 'ParticipantListRelationFilter'
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    sportId: Union[_int, 'types.IntFilter']
    sport: 'SportRelationFilter'
    teamAdminUserId: Union[_int, 'types.IntFilter']
    admin: 'UserRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    amountPaidInCents: Union[_int, 'types.IntFilter']
    amountToPayInCents: Union[_int, 'types.IntFilter']
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive3', List['TeamWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive3']
    OR: List['TeamWhereInputRecursive3']
    NOT: List['TeamWhereInputRecursive3']


class TeamWhereInputRecursive3(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    participants: 'ParticipantListRelationFilter'
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    sportId: Union[_int, 'types.IntFilter']
    sport: 'SportRelationFilter'
    teamAdminUserId: Union[_int, 'types.IntFilter']
    admin: 'UserRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    amountPaidInCents: Union[_int, 'types.IntFilter']
    amountToPayInCents: Union[_int, 'types.IntFilter']
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive4', List['TeamWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive4']
    OR: List['TeamWhereInputRecursive4']
    NOT: List['TeamWhereInputRecursive4']


class TeamWhereInputRecursive4(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    participants: 'ParticipantListRelationFilter'
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    sportId: Union[_int, 'types.IntFilter']
    sport: 'SportRelationFilter'
    teamAdminUserId: Union[_int, 'types.IntFilter']
    admin: 'UserRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    amountPaidInCents: Union[_int, 'types.IntFilter']
    amountToPayInCents: Union[_int, 'types.IntFilter']
    Payment: 'PaymentListRelationFilter'



# aggregate Team types


    

class TeamScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    sportId: Union[_int, 'types.IntWithAggregatesFilter']
    teamAdminUserId: Union[_int, 'types.IntWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    amountPaidInCents: Union[_int, 'types.IntWithAggregatesFilter']
    amountToPayInCents: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive1']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive1']


class TeamScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    sportId: Union[_int, 'types.IntWithAggregatesFilter']
    teamAdminUserId: Union[_int, 'types.IntWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    amountPaidInCents: Union[_int, 'types.IntWithAggregatesFilter']
    amountToPayInCents: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive2']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive2']


class TeamScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    sportId: Union[_int, 'types.IntWithAggregatesFilter']
    teamAdminUserId: Union[_int, 'types.IntWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    amountPaidInCents: Union[_int, 'types.IntWithAggregatesFilter']
    amountToPayInCents: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive3']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive3']


class TeamScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    sportId: Union[_int, 'types.IntWithAggregatesFilter']
    teamAdminUserId: Union[_int, 'types.IntWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    amountPaidInCents: Union[_int, 'types.IntWithAggregatesFilter']
    amountToPayInCents: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive4']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive4']


class TeamScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TeamStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    sportId: Union[_int, 'types.IntWithAggregatesFilter']
    teamAdminUserId: Union[_int, 'types.IntWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    amountPaidInCents: Union[_int, 'types.IntWithAggregatesFilter']
    amountToPayInCents: Union[_int, 'types.IntWithAggregatesFilter']



class TeamGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    status: 'enums.TeamStatus'
    createdAt: datetime.datetime
    sportId: _int
    teamAdminUserId: _int
    schoolId: _int
    amountPaidInCents: _int
    amountToPayInCents: _int
    _sum: 'TeamSumAggregateOutput'
    _avg: 'TeamAvgAggregateOutput'
    _min: 'TeamMinAggregateOutput'
    _max: 'TeamMaxAggregateOutput'
    _count: 'TeamCountAggregateOutput'


class TeamAvgAggregateOutput(TypedDict, total=False):
    """Team output for aggregating averages"""
    id: float
    sportId: float
    teamAdminUserId: float
    schoolId: float
    amountPaidInCents: float
    amountToPayInCents: float


class TeamSumAggregateOutput(TypedDict, total=False):
    """Team output for aggregating sums"""
    id: _int
    sportId: _int
    teamAdminUserId: _int
    schoolId: _int
    amountPaidInCents: _int
    amountToPayInCents: _int


class TeamScalarAggregateOutput(TypedDict, total=False):
    """Team output including scalar fields"""
    id: _int
    name: _str
    status: 'enums.TeamStatus'
    createdAt: datetime.datetime
    sportId: _int
    teamAdminUserId: _int
    schoolId: _int
    amountPaidInCents: _int
    amountToPayInCents: _int


TeamMinAggregateOutput = TeamScalarAggregateOutput
TeamMaxAggregateOutput = TeamScalarAggregateOutput


class TeamMaxAggregateInput(TypedDict, total=False):
    """Team input for aggregating by max"""
    id: bool
    name: bool
    status: bool
    createdAt: bool
    sportId: bool
    teamAdminUserId: bool
    schoolId: bool
    amountPaidInCents: bool
    amountToPayInCents: bool


class TeamMinAggregateInput(TypedDict, total=False):
    """Team input for aggregating by min"""
    id: bool
    name: bool
    status: bool
    createdAt: bool
    sportId: bool
    teamAdminUserId: bool
    schoolId: bool
    amountPaidInCents: bool
    amountToPayInCents: bool


class TeamNumberAggregateInput(TypedDict, total=False):
    """Team input for aggregating numbers"""
    id: bool
    sportId: bool
    teamAdminUserId: bool
    schoolId: bool
    amountPaidInCents: bool
    amountToPayInCents: bool


TeamAvgAggregateInput = TeamNumberAggregateInput
TeamSumAggregateInput = TeamNumberAggregateInput


TeamCountAggregateInput = TypedDict(
    'TeamCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'status': bool,
        'createdAt': bool,
        'sportId': bool,
        'teamAdminUserId': bool,
        'schoolId': bool,
        'amountPaidInCents': bool,
        'amountToPayInCents': bool,
        '_all': bool,
    },
    total=False,
)

TeamCountAggregateOutput = TypedDict(
    'TeamCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'status': int,
        'createdAt': int,
        'sportId': int,
        'teamAdminUserId': int,
        'schoolId': int,
        'amountPaidInCents': int,
        'amountToPayInCents': int,
        '_all': int,
    },
    total=False,
)


TeamKeys = Literal[
    'id',
    'name',
    'participants',
    'status',
    'createdAt',
    'sportId',
    'sport',
    'teamAdminUserId',
    'admin',
    'schoolId',
    'school',
    'amountPaidInCents',
    'amountToPayInCents',
    'Payment',
]
TeamScalarFieldKeys = Literal[
    'id',
    'name',
    'status',
    'createdAt',
    'sportId',
    'teamAdminUserId',
    'schoolId',
    'amountPaidInCents',
    'amountToPayInCents',
]
TeamScalarFieldKeysT = TypeVar('TeamScalarFieldKeysT', bound=TeamScalarFieldKeys)

TeamRelationalFieldKeys = Literal[
        'participants',
        'sport',
        'admin',
        'school',
        'Payment',
    ]

# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _int
    teams: 'TeamCreateManyNestedWithoutRelationsInput'
    schoolId: _int
    school: 'SchoolCreateNestedWithoutRelationsInput'
    status: 'enums.EnumUserStatus'
    sportAdminId: Optional[_int]
    sportAdmin: 'SportCreateNestedWithoutRelationsInput'
    Payment: 'PaymentCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str
    password: _str
    firstname: _str
    lastname: _str
    mobile: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _int
    schoolId: _int
    status: 'enums.EnumUserStatus'
    sportAdminId: Optional[_int]


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str
    password: _str
    firstname: _str
    lastname: _str
    mobile: _str


class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]


_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    email: _str
    password: _str
    firstname: _str
    lastname: _str
    mobile: _str
    teams: 'TeamUpdateManyWithoutRelationsInput'
    school: 'SchoolUpdateOneWithoutRelationsInput'
    status: 'enums.EnumUserStatus'
    sportAdmin: 'SportUpdateOneWithoutRelationsInput'
    Payment: 'PaymentUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    email: _str
    password: _str
    firstname: _str
    lastname: _str
    mobile: _str
    status: 'enums.EnumUserStatus'


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_password_OrderByInput = TypedDict(
    '_User_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_User_firstname_OrderByInput = TypedDict(
    '_User_firstname_OrderByInput',
    {
        'firstname': 'SortOrder',
    },
    total=True
)

_User_lastname_OrderByInput = TypedDict(
    '_User_lastname_OrderByInput',
    {
        'lastname': 'SortOrder',
    },
    total=True
)

_User_mobile_OrderByInput = TypedDict(
    '_User_mobile_OrderByInput',
    {
        'mobile': 'SortOrder',
    },
    total=True
)

_User_schoolId_OrderByInput = TypedDict(
    '_User_schoolId_OrderByInput',
    {
        'schoolId': 'SortOrder',
    },
    total=True
)

_User_status_OrderByInput = TypedDict(
    '_User_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_User_sportAdminId_OrderByInput = TypedDict(
    '_User_sportAdminId_OrderByInput',
    {
        'sportAdminId': 'SortOrder',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_password_OrderByInput',
    '_User_firstname_OrderByInput',
    '_User_lastname_OrderByInput',
    '_User_mobile_OrderByInput',
    '_User_schoolId_OrderByInput',
    '_User_status_OrderByInput',
    '_User_sportAdminId_OrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    teams: Union[bool, 'FindManyTeamArgsFromUser']
    school: Union[bool, 'SchoolArgsFromUser']
    sportAdmin: Union[bool, 'SportArgsFromUser']
    Payment: Union[bool, 'FindManyPaymentArgsFromUser']


    

class SportIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive1']
    admins: Union[bool, 'FindManyUserArgsFromUserRecursive1']


class SportIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive2']
    admins: Union[bool, 'FindManyUserArgsFromUserRecursive2']


class SportIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive3']
    admins: Union[bool, 'FindManyUserArgsFromUserRecursive3']


class SportIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive4']
    admins: Union[bool, 'FindManyUserArgsFromUserRecursive4']


class SportIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class SportArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SportIncludeFromSportRecursive1'


class SportArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'SportIncludeFromSportRecursive2'


class SportArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'SportIncludeFromSportRecursive3'


class SportArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'SportIncludeFromSportRecursive4'


class SportArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManySportArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive1'


class FindManySportArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive2'


class FindManySportArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive3'


class FindManySportArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive4'


class FindManySportArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    
    

class TeamIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive1']
    sport: Union[bool, 'SportArgsFromUserRecursive1']
    admin: Union[bool, 'UserArgsFromUserRecursive1']
    school: Union[bool, 'SchoolArgsFromUserRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive1']


class TeamIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive2']
    sport: Union[bool, 'SportArgsFromUserRecursive2']
    admin: Union[bool, 'UserArgsFromUserRecursive2']
    school: Union[bool, 'SchoolArgsFromUserRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive2']


class TeamIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive3']
    sport: Union[bool, 'SportArgsFromUserRecursive3']
    admin: Union[bool, 'UserArgsFromUserRecursive3']
    school: Union[bool, 'SchoolArgsFromUserRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive3']


class TeamIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive4']
    sport: Union[bool, 'SportArgsFromUserRecursive4']
    admin: Union[bool, 'UserArgsFromUserRecursive4']
    school: Union[bool, 'SchoolArgsFromUserRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive4']


class TeamIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class TeamArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyTeamArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive1']
    school: Union[bool, 'SchoolArgsFromUserRecursive1']
    sportAdmin: Union[bool, 'SportArgsFromUserRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive2']
    school: Union[bool, 'SchoolArgsFromUserRecursive2']
    sportAdmin: Union[bool, 'SportArgsFromUserRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive3']
    school: Union[bool, 'SchoolArgsFromUserRecursive3']
    sportAdmin: Union[bool, 'SportArgsFromUserRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive4']
    school: Union[bool, 'SchoolArgsFromUserRecursive4']
    sportAdmin: Union[bool, 'SportArgsFromUserRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ParticipantIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    school: Union[bool, 'SchoolArgsFromUserRecursive1']
    team: Union[bool, 'TeamArgsFromUserRecursive1']


class ParticipantIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    school: Union[bool, 'SchoolArgsFromUserRecursive2']
    team: Union[bool, 'TeamArgsFromUserRecursive2']


class ParticipantIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    school: Union[bool, 'SchoolArgsFromUserRecursive3']
    team: Union[bool, 'TeamArgsFromUserRecursive3']


class ParticipantIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    school: Union[bool, 'SchoolArgsFromUserRecursive4']
    team: Union[bool, 'TeamArgsFromUserRecursive4']


class ParticipantIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class ParticipantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyParticipantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class SchoolIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive1']


class SchoolIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive2']


class SchoolIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive3']


class SchoolIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive4']


class SchoolIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class SchoolArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SchoolIncludeFromSchoolRecursive1'


class SchoolArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'SchoolIncludeFromSchoolRecursive2'


class SchoolArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'SchoolIncludeFromSchoolRecursive3'


class SchoolArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'SchoolIncludeFromSchoolRecursive4'


class SchoolArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManySchoolArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive1'


class FindManySchoolArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive2'


class FindManySchoolArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive3'


class FindManySchoolArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive4'


class FindManySchoolArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    
    

class GeneralConfigIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class GeneralConfigIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class GeneralConfigIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""


class GeneralConfigIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""


class GeneralConfigIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class GeneralConfigArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class GeneralConfigArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class GeneralConfigArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class GeneralConfigArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class GeneralConfigArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyGeneralConfigArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class FindManyGeneralConfigArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class FindManyGeneralConfigArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class FindManyGeneralConfigArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class FindManyGeneralConfigArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    
    

class PaymentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    team: Union[bool, 'TeamArgsFromUserRecursive1']


class PaymentIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    team: Union[bool, 'TeamArgsFromUserRecursive2']


class PaymentIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    team: Union[bool, 'TeamArgsFromUserRecursive3']


class PaymentIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    team: Union[bool, 'TeamArgsFromUserRecursive4']


class PaymentIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class PaymentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentIncludeFromPaymentRecursive1'


class PaymentArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentIncludeFromPaymentRecursive2'


class PaymentArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentIncludeFromPaymentRecursive3'


class PaymentArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentIncludeFromPaymentRecursive4'


class PaymentArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyPaymentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive1'


class FindManyPaymentArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive2'


class FindManyPaymentArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive3'


class FindManyPaymentArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive4'


class FindManyPaymentArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    mobile: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[None, _int, 'types.IntFilter']
    sportAdmin: 'SportRelationFilter'
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    mobile: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[None, _int, 'types.IntFilter']
    sportAdmin: 'SportRelationFilter'
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    mobile: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[None, _int, 'types.IntFilter']
    sportAdmin: 'SportRelationFilter'
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    mobile: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[None, _int, 'types.IntFilter']
    sportAdmin: 'SportRelationFilter'
    Payment: 'PaymentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    mobile: Union[_str, 'types.StringFilter']
    teams: 'TeamListRelationFilter'
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[None, _int, 'types.IntFilter']
    sportAdmin: 'SportRelationFilter'
    Payment: 'PaymentListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    mobile: Union[_str, 'types.StringWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    mobile: Union[_str, 'types.StringWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    mobile: Union[_str, 'types.StringWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    mobile: Union[_str, 'types.StringWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    mobile: Union[_str, 'types.StringWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    status: 'enums.EnumUserStatus'
    sportAdminId: Union[_int, 'types.IntWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _int
    email: _str
    password: _str
    firstname: _str
    lastname: _str
    mobile: _str
    schoolId: _int
    status: 'enums.EnumUserStatus'
    sportAdminId: _int
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""
    id: float
    schoolId: float
    sportAdminId: float


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""
    id: _int
    schoolId: _int
    sportAdminId: _int


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _int
    email: _str
    password: _str
    firstname: _str
    lastname: _str
    mobile: _str
    schoolId: _int
    status: 'enums.EnumUserStatus'
    sportAdminId: _int


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    password: bool
    firstname: bool
    lastname: bool
    mobile: bool
    schoolId: bool
    status: bool
    sportAdminId: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    password: bool
    firstname: bool
    lastname: bool
    mobile: bool
    schoolId: bool
    status: bool
    sportAdminId: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""
    id: bool
    schoolId: bool
    sportAdminId: bool


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'password': bool,
        'firstname': bool,
        'lastname': bool,
        'mobile': bool,
        'schoolId': bool,
        'status': bool,
        'sportAdminId': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'password': int,
        'firstname': int,
        'lastname': int,
        'mobile': int,
        'schoolId': int,
        'status': int,
        'sportAdminId': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'password',
    'firstname',
    'lastname',
    'mobile',
    'teams',
    'schoolId',
    'school',
    'status',
    'sportAdminId',
    'sportAdmin',
    'Payment',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'password',
    'firstname',
    'lastname',
    'mobile',
    'schoolId',
    'status',
    'sportAdminId',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'teams',
        'school',
        'sportAdmin',
        'Payment',
    ]

# Participant types

class ParticipantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Participant create method"""
    id: _int
    createdAt: datetime.datetime
    schoolId: _int
    school: 'SchoolCreateNestedWithoutRelationsInput'
    teamId: _int
    team: 'TeamCreateNestedWithoutRelationsInput'
    charteEmailSent: _bool
    certificateOK: _bool


class ParticipantCreateInput(ParticipantOptionalCreateInput):
    """Required arguments to the Participant create method"""
    gender: 'enums.Gender'
    firstname: _str
    lastname: _str
    email: _str
    dateOfBirth: datetime.datetime
    charteIsValidated: _bool
    chartePassword: _str
    isCaptain: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ParticipantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Participant create method, without relations"""
    id: _int
    createdAt: datetime.datetime
    schoolId: _int
    teamId: _int
    charteEmailSent: _bool
    certificateOK: _bool


class ParticipantCreateWithoutRelationsInput(ParticipantOptionalCreateWithoutRelationsInput):
    """Required arguments to the Participant create method, without relations"""
    gender: 'enums.Gender'
    firstname: _str
    lastname: _str
    email: _str
    dateOfBirth: datetime.datetime
    charteIsValidated: _bool
    chartePassword: _str
    isCaptain: _bool


class ParticipantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ParticipantCreateWithoutRelationsInput'
    connect: 'ParticipantWhereUniqueInput'


class ParticipantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ParticipantCreateWithoutRelationsInput', List['ParticipantCreateWithoutRelationsInput']]
    connect: Union['ParticipantWhereUniqueInput', List['ParticipantWhereUniqueInput']]


_ParticipantWhereUnique_id_Input = TypedDict(
    '_ParticipantWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_ParticipantWhereUnique_email_Input = TypedDict(
    '_ParticipantWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

ParticipantWhereUniqueInput = Union[
    '_ParticipantWhereUnique_id_Input',
    '_ParticipantWhereUnique_email_Input',
]


class ParticipantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    gender: 'enums.Gender'
    firstname: _str
    lastname: _str
    email: _str
    dateOfBirth: datetime.datetime
    charteIsValidated: _bool
    chartePassword: _str
    createdAt: datetime.datetime
    isCaptain: _bool
    school: 'SchoolUpdateOneWithoutRelationsInput'
    team: 'TeamUpdateOneWithoutRelationsInput'
    charteEmailSent: _bool
    certificateOK: _bool


class ParticipantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    gender: 'enums.Gender'
    firstname: _str
    lastname: _str
    email: _str
    dateOfBirth: datetime.datetime
    charteIsValidated: _bool
    chartePassword: _str
    createdAt: datetime.datetime
    isCaptain: _bool
    charteEmailSent: _bool
    certificateOK: _bool


class ParticipantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ParticipantCreateWithoutRelationsInput']
    connect: List['ParticipantWhereUniqueInput']
    set: List['ParticipantWhereUniqueInput']
    disconnect: List['ParticipantWhereUniqueInput']
    delete: List['ParticipantWhereUniqueInput']

    # TODO
    # update: List['ParticipantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ParticipantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ParticipantScalarWhereInput']
    # upsert: List['ParticipantUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ParticipantCreateOrConnectWithoutRelationsInput']


class ParticipantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ParticipantCreateWithoutRelationsInput'
    connect: 'ParticipantWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ParticipantUpdateInput'
    # upsert: 'ParticipantUpsertWithoutRelationsInput'
    # connectOrCreate: 'ParticipantCreateOrConnectWithoutRelationsInput'


class ParticipantUpsertInput(TypedDict):
    create: 'ParticipantCreateInput'
    update: 'ParticipantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Participant_id_OrderByInput = TypedDict(
    '_Participant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Participant_gender_OrderByInput = TypedDict(
    '_Participant_gender_OrderByInput',
    {
        'gender': 'SortOrder',
    },
    total=True
)

_Participant_firstname_OrderByInput = TypedDict(
    '_Participant_firstname_OrderByInput',
    {
        'firstname': 'SortOrder',
    },
    total=True
)

_Participant_lastname_OrderByInput = TypedDict(
    '_Participant_lastname_OrderByInput',
    {
        'lastname': 'SortOrder',
    },
    total=True
)

_Participant_email_OrderByInput = TypedDict(
    '_Participant_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Participant_dateOfBirth_OrderByInput = TypedDict(
    '_Participant_dateOfBirth_OrderByInput',
    {
        'dateOfBirth': 'SortOrder',
    },
    total=True
)

_Participant_charteIsValidated_OrderByInput = TypedDict(
    '_Participant_charteIsValidated_OrderByInput',
    {
        'charteIsValidated': 'SortOrder',
    },
    total=True
)

_Participant_chartePassword_OrderByInput = TypedDict(
    '_Participant_chartePassword_OrderByInput',
    {
        'chartePassword': 'SortOrder',
    },
    total=True
)

_Participant_createdAt_OrderByInput = TypedDict(
    '_Participant_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Participant_isCaptain_OrderByInput = TypedDict(
    '_Participant_isCaptain_OrderByInput',
    {
        'isCaptain': 'SortOrder',
    },
    total=True
)

_Participant_schoolId_OrderByInput = TypedDict(
    '_Participant_schoolId_OrderByInput',
    {
        'schoolId': 'SortOrder',
    },
    total=True
)

_Participant_teamId_OrderByInput = TypedDict(
    '_Participant_teamId_OrderByInput',
    {
        'teamId': 'SortOrder',
    },
    total=True
)

_Participant_charteEmailSent_OrderByInput = TypedDict(
    '_Participant_charteEmailSent_OrderByInput',
    {
        'charteEmailSent': 'SortOrder',
    },
    total=True
)

_Participant_certificateOK_OrderByInput = TypedDict(
    '_Participant_certificateOK_OrderByInput',
    {
        'certificateOK': 'SortOrder',
    },
    total=True
)

ParticipantOrderByInput = Union[
    '_Participant_id_OrderByInput',
    '_Participant_gender_OrderByInput',
    '_Participant_firstname_OrderByInput',
    '_Participant_lastname_OrderByInput',
    '_Participant_email_OrderByInput',
    '_Participant_dateOfBirth_OrderByInput',
    '_Participant_charteIsValidated_OrderByInput',
    '_Participant_chartePassword_OrderByInput',
    '_Participant_createdAt_OrderByInput',
    '_Participant_isCaptain_OrderByInput',
    '_Participant_schoolId_OrderByInput',
    '_Participant_teamId_OrderByInput',
    '_Participant_charteEmailSent_OrderByInput',
    '_Participant_certificateOK_OrderByInput',
]



# recursive Participant types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ParticipantRelationFilter = TypedDict(
    'ParticipantRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ParticipantListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ParticipantInclude(TypedDict, total=False):
    """Participant relational arguments"""
    school: Union[bool, 'SchoolArgsFromParticipant']
    team: Union[bool, 'TeamArgsFromParticipant']


    

class SportIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive1']
    admins: Union[bool, 'FindManyUserArgsFromParticipantRecursive1']


class SportIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive2']
    admins: Union[bool, 'FindManyUserArgsFromParticipantRecursive2']


class SportIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive3']
    admins: Union[bool, 'FindManyUserArgsFromParticipantRecursive3']


class SportIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive4']
    admins: Union[bool, 'FindManyUserArgsFromParticipantRecursive4']


class SportIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class SportArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SportIncludeFromSportRecursive1'


class SportArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SportIncludeFromSportRecursive2'


class SportArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SportIncludeFromSportRecursive3'


class SportArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SportIncludeFromSportRecursive4'


class SportArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManySportArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive1'


class FindManySportArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive2'


class FindManySportArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive3'


class FindManySportArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive4'


class FindManySportArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    
    

class TeamIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive1']
    sport: Union[bool, 'SportArgsFromParticipantRecursive1']
    admin: Union[bool, 'UserArgsFromParticipantRecursive1']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive1']


class TeamIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive2']
    sport: Union[bool, 'SportArgsFromParticipantRecursive2']
    admin: Union[bool, 'UserArgsFromParticipantRecursive2']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive2']


class TeamIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive3']
    sport: Union[bool, 'SportArgsFromParticipantRecursive3']
    admin: Union[bool, 'UserArgsFromParticipantRecursive3']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive3']


class TeamIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive4']
    sport: Union[bool, 'SportArgsFromParticipantRecursive4']
    admin: Union[bool, 'UserArgsFromParticipantRecursive4']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive4']


class TeamIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class TeamArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyTeamArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class UserIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive1']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive1']
    sportAdmin: Union[bool, 'SportArgsFromParticipantRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive1']


class UserIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive2']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive2']
    sportAdmin: Union[bool, 'SportArgsFromParticipantRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive2']


class UserIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive3']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive3']
    sportAdmin: Union[bool, 'SportArgsFromParticipantRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive3']


class UserIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive4']
    school: Union[bool, 'SchoolArgsFromParticipantRecursive4']
    sportAdmin: Union[bool, 'SportArgsFromParticipantRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromParticipantRecursive4']


class UserIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class UserArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyUserArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ParticipantIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    school: Union[bool, 'SchoolArgsFromParticipantRecursive1']
    team: Union[bool, 'TeamArgsFromParticipantRecursive1']


class ParticipantIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    school: Union[bool, 'SchoolArgsFromParticipantRecursive2']
    team: Union[bool, 'TeamArgsFromParticipantRecursive2']


class ParticipantIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    school: Union[bool, 'SchoolArgsFromParticipantRecursive3']
    team: Union[bool, 'TeamArgsFromParticipantRecursive3']


class ParticipantIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    school: Union[bool, 'SchoolArgsFromParticipantRecursive4']
    team: Union[bool, 'TeamArgsFromParticipantRecursive4']


class ParticipantIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class ParticipantArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyParticipantArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class SchoolIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    users: Union[bool, 'FindManyUserArgsFromParticipantRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive1']


class SchoolIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    users: Union[bool, 'FindManyUserArgsFromParticipantRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive2']


class SchoolIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    users: Union[bool, 'FindManyUserArgsFromParticipantRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive3']


class SchoolIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    users: Union[bool, 'FindManyUserArgsFromParticipantRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive4']


class SchoolIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class SchoolArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SchoolIncludeFromSchoolRecursive1'


class SchoolArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SchoolIncludeFromSchoolRecursive2'


class SchoolArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SchoolIncludeFromSchoolRecursive3'


class SchoolArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'SchoolIncludeFromSchoolRecursive4'


class SchoolArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManySchoolArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive1'


class FindManySchoolArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive2'


class FindManySchoolArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive3'


class FindManySchoolArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive4'


class FindManySchoolArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    
    

class GeneralConfigIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""


class GeneralConfigIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""


class GeneralConfigIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""


class GeneralConfigIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""


class GeneralConfigIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class GeneralConfigArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class GeneralConfigArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class GeneralConfigArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class GeneralConfigArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class GeneralConfigArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyGeneralConfigArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class FindManyGeneralConfigArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class FindManyGeneralConfigArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class FindManyGeneralConfigArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class FindManyGeneralConfigArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    
    

class PaymentIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    user: Union[bool, 'UserArgsFromParticipantRecursive1']
    team: Union[bool, 'TeamArgsFromParticipantRecursive1']


class PaymentIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    user: Union[bool, 'UserArgsFromParticipantRecursive2']
    team: Union[bool, 'TeamArgsFromParticipantRecursive2']


class PaymentIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    user: Union[bool, 'UserArgsFromParticipantRecursive3']
    team: Union[bool, 'TeamArgsFromParticipantRecursive3']


class PaymentIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    user: Union[bool, 'UserArgsFromParticipantRecursive4']
    team: Union[bool, 'TeamArgsFromParticipantRecursive4']


class PaymentIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class PaymentArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'PaymentIncludeFromPaymentRecursive1'


class PaymentArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'PaymentIncludeFromPaymentRecursive2'


class PaymentArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'PaymentIncludeFromPaymentRecursive3'


class PaymentArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'PaymentIncludeFromPaymentRecursive4'


class PaymentArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyPaymentArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive1'


class FindManyPaymentArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive2'


class FindManyPaymentArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive3'


class FindManyPaymentArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive4'


class FindManyPaymentArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    


FindManyParticipantArgs = FindManyParticipantArgsFromParticipant
FindFirstParticipantArgs = FindManyParticipantArgsFromParticipant


    

class ParticipantWhereInput(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeFilter']
    charteIsValidated: Union[_bool, 'types.BooleanFilter']
    chartePassword: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    isCaptain: Union[_bool, 'types.BooleanFilter']
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    charteEmailSent: Union[_bool, 'types.BooleanFilter']
    certificateOK: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive1', List['ParticipantWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive1']
    OR: List['ParticipantWhereInputRecursive1']
    NOT: List['ParticipantWhereInputRecursive1']


class ParticipantWhereInputRecursive1(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeFilter']
    charteIsValidated: Union[_bool, 'types.BooleanFilter']
    chartePassword: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    isCaptain: Union[_bool, 'types.BooleanFilter']
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    charteEmailSent: Union[_bool, 'types.BooleanFilter']
    certificateOK: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive2', List['ParticipantWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive2']
    OR: List['ParticipantWhereInputRecursive2']
    NOT: List['ParticipantWhereInputRecursive2']


class ParticipantWhereInputRecursive2(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeFilter']
    charteIsValidated: Union[_bool, 'types.BooleanFilter']
    chartePassword: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    isCaptain: Union[_bool, 'types.BooleanFilter']
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    charteEmailSent: Union[_bool, 'types.BooleanFilter']
    certificateOK: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive3', List['ParticipantWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive3']
    OR: List['ParticipantWhereInputRecursive3']
    NOT: List['ParticipantWhereInputRecursive3']


class ParticipantWhereInputRecursive3(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeFilter']
    charteIsValidated: Union[_bool, 'types.BooleanFilter']
    chartePassword: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    isCaptain: Union[_bool, 'types.BooleanFilter']
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    charteEmailSent: Union[_bool, 'types.BooleanFilter']
    certificateOK: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive4', List['ParticipantWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive4']
    OR: List['ParticipantWhereInputRecursive4']
    NOT: List['ParticipantWhereInputRecursive4']


class ParticipantWhereInputRecursive4(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringFilter']
    lastname: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeFilter']
    charteIsValidated: Union[_bool, 'types.BooleanFilter']
    chartePassword: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    isCaptain: Union[_bool, 'types.BooleanFilter']
    schoolId: Union[_int, 'types.IntFilter']
    school: 'SchoolRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    charteEmailSent: Union[_bool, 'types.BooleanFilter']
    certificateOK: Union[_bool, 'types.BooleanFilter']



# aggregate Participant types


    

class ParticipantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    charteIsValidated: Union[_bool, 'types.BooleanWithAggregatesFilter']
    chartePassword: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    isCaptain: Union[_bool, 'types.BooleanWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    charteEmailSent: Union[_bool, 'types.BooleanWithAggregatesFilter']
    certificateOK: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive1']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive1']


class ParticipantScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    charteIsValidated: Union[_bool, 'types.BooleanWithAggregatesFilter']
    chartePassword: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    isCaptain: Union[_bool, 'types.BooleanWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    charteEmailSent: Union[_bool, 'types.BooleanWithAggregatesFilter']
    certificateOK: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive2']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive2']


class ParticipantScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    charteIsValidated: Union[_bool, 'types.BooleanWithAggregatesFilter']
    chartePassword: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    isCaptain: Union[_bool, 'types.BooleanWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    charteEmailSent: Union[_bool, 'types.BooleanWithAggregatesFilter']
    certificateOK: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive3']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive3']


class ParticipantScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    charteIsValidated: Union[_bool, 'types.BooleanWithAggregatesFilter']
    chartePassword: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    isCaptain: Union[_bool, 'types.BooleanWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    charteEmailSent: Union[_bool, 'types.BooleanWithAggregatesFilter']
    certificateOK: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive4']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive4']


class ParticipantScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    gender: 'enums.Gender'
    firstname: Union[_str, 'types.StringWithAggregatesFilter']
    lastname: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    dateOfBirth: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    charteIsValidated: Union[_bool, 'types.BooleanWithAggregatesFilter']
    chartePassword: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    isCaptain: Union[_bool, 'types.BooleanWithAggregatesFilter']
    schoolId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    charteEmailSent: Union[_bool, 'types.BooleanWithAggregatesFilter']
    certificateOK: Union[_bool, 'types.BooleanWithAggregatesFilter']



class ParticipantGroupByOutput(TypedDict, total=False):
    id: _int
    gender: 'enums.Gender'
    firstname: _str
    lastname: _str
    email: _str
    dateOfBirth: datetime.datetime
    charteIsValidated: _bool
    chartePassword: _str
    createdAt: datetime.datetime
    isCaptain: _bool
    schoolId: _int
    teamId: _int
    charteEmailSent: _bool
    certificateOK: _bool
    _sum: 'ParticipantSumAggregateOutput'
    _avg: 'ParticipantAvgAggregateOutput'
    _min: 'ParticipantMinAggregateOutput'
    _max: 'ParticipantMaxAggregateOutput'
    _count: 'ParticipantCountAggregateOutput'


class ParticipantAvgAggregateOutput(TypedDict, total=False):
    """Participant output for aggregating averages"""
    id: float
    schoolId: float
    teamId: float


class ParticipantSumAggregateOutput(TypedDict, total=False):
    """Participant output for aggregating sums"""
    id: _int
    schoolId: _int
    teamId: _int


class ParticipantScalarAggregateOutput(TypedDict, total=False):
    """Participant output including scalar fields"""
    id: _int
    gender: 'enums.Gender'
    firstname: _str
    lastname: _str
    email: _str
    dateOfBirth: datetime.datetime
    charteIsValidated: _bool
    chartePassword: _str
    createdAt: datetime.datetime
    isCaptain: _bool
    schoolId: _int
    teamId: _int
    charteEmailSent: _bool
    certificateOK: _bool


ParticipantMinAggregateOutput = ParticipantScalarAggregateOutput
ParticipantMaxAggregateOutput = ParticipantScalarAggregateOutput


class ParticipantMaxAggregateInput(TypedDict, total=False):
    """Participant input for aggregating by max"""
    id: bool
    gender: bool
    firstname: bool
    lastname: bool
    email: bool
    dateOfBirth: bool
    charteIsValidated: bool
    chartePassword: bool
    createdAt: bool
    isCaptain: bool
    schoolId: bool
    teamId: bool
    charteEmailSent: bool
    certificateOK: bool


class ParticipantMinAggregateInput(TypedDict, total=False):
    """Participant input for aggregating by min"""
    id: bool
    gender: bool
    firstname: bool
    lastname: bool
    email: bool
    dateOfBirth: bool
    charteIsValidated: bool
    chartePassword: bool
    createdAt: bool
    isCaptain: bool
    schoolId: bool
    teamId: bool
    charteEmailSent: bool
    certificateOK: bool


class ParticipantNumberAggregateInput(TypedDict, total=False):
    """Participant input for aggregating numbers"""
    id: bool
    schoolId: bool
    teamId: bool


ParticipantAvgAggregateInput = ParticipantNumberAggregateInput
ParticipantSumAggregateInput = ParticipantNumberAggregateInput


ParticipantCountAggregateInput = TypedDict(
    'ParticipantCountAggregateInput',
    {
        'id': bool,
        'gender': bool,
        'firstname': bool,
        'lastname': bool,
        'email': bool,
        'dateOfBirth': bool,
        'charteIsValidated': bool,
        'chartePassword': bool,
        'createdAt': bool,
        'isCaptain': bool,
        'schoolId': bool,
        'teamId': bool,
        'charteEmailSent': bool,
        'certificateOK': bool,
        '_all': bool,
    },
    total=False,
)

ParticipantCountAggregateOutput = TypedDict(
    'ParticipantCountAggregateOutput',
    {
        'id': int,
        'gender': int,
        'firstname': int,
        'lastname': int,
        'email': int,
        'dateOfBirth': int,
        'charteIsValidated': int,
        'chartePassword': int,
        'createdAt': int,
        'isCaptain': int,
        'schoolId': int,
        'teamId': int,
        'charteEmailSent': int,
        'certificateOK': int,
        '_all': int,
    },
    total=False,
)


ParticipantKeys = Literal[
    'id',
    'gender',
    'firstname',
    'lastname',
    'email',
    'dateOfBirth',
    'charteIsValidated',
    'chartePassword',
    'createdAt',
    'isCaptain',
    'schoolId',
    'school',
    'teamId',
    'team',
    'charteEmailSent',
    'certificateOK',
]
ParticipantScalarFieldKeys = Literal[
    'id',
    'gender',
    'firstname',
    'lastname',
    'email',
    'dateOfBirth',
    'charteIsValidated',
    'chartePassword',
    'createdAt',
    'isCaptain',
    'schoolId',
    'teamId',
    'charteEmailSent',
    'certificateOK',
]
ParticipantScalarFieldKeysT = TypeVar('ParticipantScalarFieldKeysT', bound=ParticipantScalarFieldKeys)

ParticipantRelationalFieldKeys = Literal[
        'school',
        'team',
    ]

# School types

class SchoolOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the School create method"""
    id: _int
    users: 'UserCreateManyNestedWithoutRelationsInput'
    participants: 'ParticipantCreateManyNestedWithoutRelationsInput'
    teams: 'TeamCreateManyNestedWithoutRelationsInput'


class SchoolCreateInput(SchoolOptionalCreateInput):
    """Required arguments to the School create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SchoolOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the School create method, without relations"""
    id: _int


class SchoolCreateWithoutRelationsInput(SchoolOptionalCreateWithoutRelationsInput):
    """Required arguments to the School create method, without relations"""
    name: _str


class SchoolCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SchoolCreateWithoutRelationsInput'
    connect: 'SchoolWhereUniqueInput'


class SchoolCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SchoolCreateWithoutRelationsInput', List['SchoolCreateWithoutRelationsInput']]
    connect: Union['SchoolWhereUniqueInput', List['SchoolWhereUniqueInput']]


_SchoolWhereUnique_id_Input = TypedDict(
    '_SchoolWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

SchoolWhereUniqueInput = _SchoolWhereUnique_id_Input


class SchoolUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    users: 'UserUpdateManyWithoutRelationsInput'
    participants: 'ParticipantUpdateManyWithoutRelationsInput'
    teams: 'TeamUpdateManyWithoutRelationsInput'


class SchoolUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str


class SchoolUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SchoolCreateWithoutRelationsInput']
    connect: List['SchoolWhereUniqueInput']
    set: List['SchoolWhereUniqueInput']
    disconnect: List['SchoolWhereUniqueInput']
    delete: List['SchoolWhereUniqueInput']

    # TODO
    # update: List['SchoolUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SchoolUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SchoolScalarWhereInput']
    # upsert: List['SchoolUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SchoolCreateOrConnectWithoutRelationsInput']


class SchoolUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SchoolCreateWithoutRelationsInput'
    connect: 'SchoolWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SchoolUpdateInput'
    # upsert: 'SchoolUpsertWithoutRelationsInput'
    # connectOrCreate: 'SchoolCreateOrConnectWithoutRelationsInput'


class SchoolUpsertInput(TypedDict):
    create: 'SchoolCreateInput'
    update: 'SchoolUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_School_id_OrderByInput = TypedDict(
    '_School_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_School_name_OrderByInput = TypedDict(
    '_School_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

SchoolOrderByInput = Union[
    '_School_id_OrderByInput',
    '_School_name_OrderByInput',
]



# recursive School types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SchoolRelationFilter = TypedDict(
    'SchoolRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SchoolListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SchoolInclude(TypedDict, total=False):
    """School relational arguments"""
    users: Union[bool, 'FindManyUserArgsFromSchool']
    participants: Union[bool, 'FindManyParticipantArgsFromSchool']
    teams: Union[bool, 'FindManyTeamArgsFromSchool']


    

class SportIncludeFromSchool(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive1']
    admins: Union[bool, 'FindManyUserArgsFromSchoolRecursive1']


class SportIncludeFromSchoolRecursive1(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive2']
    admins: Union[bool, 'FindManyUserArgsFromSchoolRecursive2']


class SportIncludeFromSchoolRecursive2(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive3']
    admins: Union[bool, 'FindManyUserArgsFromSchoolRecursive3']


class SportIncludeFromSchoolRecursive3(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive4']
    admins: Union[bool, 'FindManyUserArgsFromSchoolRecursive4']


class SportIncludeFromSchoolRecursive4(TypedDict, total=False):
    """Relational arguments for School"""

    

class SportArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    include: 'SportIncludeFromSportRecursive1'


class SportArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    include: 'SportIncludeFromSportRecursive2'


class SportArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    include: 'SportIncludeFromSportRecursive3'


class SportArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    include: 'SportIncludeFromSportRecursive4'


class SportArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    
    

class FindManySportArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive1'


class FindManySportArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive2'


class FindManySportArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive3'


class FindManySportArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive4'


class FindManySportArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    
    

class TeamIncludeFromSchool(TypedDict, total=False):
    """Relational arguments for School"""
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive1']
    sport: Union[bool, 'SportArgsFromSchoolRecursive1']
    admin: Union[bool, 'UserArgsFromSchoolRecursive1']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive1']


class TeamIncludeFromSchoolRecursive1(TypedDict, total=False):
    """Relational arguments for School"""
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive2']
    sport: Union[bool, 'SportArgsFromSchoolRecursive2']
    admin: Union[bool, 'UserArgsFromSchoolRecursive2']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive2']


class TeamIncludeFromSchoolRecursive2(TypedDict, total=False):
    """Relational arguments for School"""
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive3']
    sport: Union[bool, 'SportArgsFromSchoolRecursive3']
    admin: Union[bool, 'UserArgsFromSchoolRecursive3']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive3']


class TeamIncludeFromSchoolRecursive3(TypedDict, total=False):
    """Relational arguments for School"""
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive4']
    sport: Union[bool, 'SportArgsFromSchoolRecursive4']
    admin: Union[bool, 'UserArgsFromSchoolRecursive4']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive4']


class TeamIncludeFromSchoolRecursive4(TypedDict, total=False):
    """Relational arguments for School"""

    

class TeamArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    
    

class FindManyTeamArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class UserIncludeFromSchool(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive1']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive1']
    sportAdmin: Union[bool, 'SportArgsFromSchoolRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive1']


class UserIncludeFromSchoolRecursive1(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive2']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive2']
    sportAdmin: Union[bool, 'SportArgsFromSchoolRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive2']


class UserIncludeFromSchoolRecursive2(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive3']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive3']
    sportAdmin: Union[bool, 'SportArgsFromSchoolRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive3']


class UserIncludeFromSchoolRecursive3(TypedDict, total=False):
    """Relational arguments for School"""
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive4']
    school: Union[bool, 'SchoolArgsFromSchoolRecursive4']
    sportAdmin: Union[bool, 'SportArgsFromSchoolRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromSchoolRecursive4']


class UserIncludeFromSchoolRecursive4(TypedDict, total=False):
    """Relational arguments for School"""

    

class UserArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    
    

class FindManyUserArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ParticipantIncludeFromSchool(TypedDict, total=False):
    """Relational arguments for School"""
    school: Union[bool, 'SchoolArgsFromSchoolRecursive1']
    team: Union[bool, 'TeamArgsFromSchoolRecursive1']


class ParticipantIncludeFromSchoolRecursive1(TypedDict, total=False):
    """Relational arguments for School"""
    school: Union[bool, 'SchoolArgsFromSchoolRecursive2']
    team: Union[bool, 'TeamArgsFromSchoolRecursive2']


class ParticipantIncludeFromSchoolRecursive2(TypedDict, total=False):
    """Relational arguments for School"""
    school: Union[bool, 'SchoolArgsFromSchoolRecursive3']
    team: Union[bool, 'TeamArgsFromSchoolRecursive3']


class ParticipantIncludeFromSchoolRecursive3(TypedDict, total=False):
    """Relational arguments for School"""
    school: Union[bool, 'SchoolArgsFromSchoolRecursive4']
    team: Union[bool, 'TeamArgsFromSchoolRecursive4']


class ParticipantIncludeFromSchoolRecursive4(TypedDict, total=False):
    """Relational arguments for School"""

    

class ParticipantArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    
    

class FindManyParticipantArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class SchoolIncludeFromSchool(TypedDict, total=False):
    """Relational arguments for School"""
    users: Union[bool, 'FindManyUserArgsFromSchoolRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive1']


class SchoolIncludeFromSchoolRecursive1(TypedDict, total=False):
    """Relational arguments for School"""
    users: Union[bool, 'FindManyUserArgsFromSchoolRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive2']


class SchoolIncludeFromSchoolRecursive2(TypedDict, total=False):
    """Relational arguments for School"""
    users: Union[bool, 'FindManyUserArgsFromSchoolRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive3']


class SchoolIncludeFromSchoolRecursive3(TypedDict, total=False):
    """Relational arguments for School"""
    users: Union[bool, 'FindManyUserArgsFromSchoolRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromSchoolRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromSchoolRecursive4']


class SchoolIncludeFromSchoolRecursive4(TypedDict, total=False):
    """Relational arguments for School"""

    

class SchoolArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    include: 'SchoolIncludeFromSchoolRecursive1'


class SchoolArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    include: 'SchoolIncludeFromSchoolRecursive2'


class SchoolArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    include: 'SchoolIncludeFromSchoolRecursive3'


class SchoolArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    include: 'SchoolIncludeFromSchoolRecursive4'


class SchoolArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    
    

class FindManySchoolArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive1'


class FindManySchoolArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive2'


class FindManySchoolArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive3'


class FindManySchoolArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive4'


class FindManySchoolArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    
    

class GeneralConfigIncludeFromSchool(TypedDict, total=False):
    """Relational arguments for School"""


class GeneralConfigIncludeFromSchoolRecursive1(TypedDict, total=False):
    """Relational arguments for School"""


class GeneralConfigIncludeFromSchoolRecursive2(TypedDict, total=False):
    """Relational arguments for School"""


class GeneralConfigIncludeFromSchoolRecursive3(TypedDict, total=False):
    """Relational arguments for School"""


class GeneralConfigIncludeFromSchoolRecursive4(TypedDict, total=False):
    """Relational arguments for School"""

    

class GeneralConfigArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class GeneralConfigArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class GeneralConfigArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class GeneralConfigArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class GeneralConfigArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    
    

class FindManyGeneralConfigArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class FindManyGeneralConfigArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class FindManyGeneralConfigArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class FindManyGeneralConfigArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class FindManyGeneralConfigArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    
    

class PaymentIncludeFromSchool(TypedDict, total=False):
    """Relational arguments for School"""
    user: Union[bool, 'UserArgsFromSchoolRecursive1']
    team: Union[bool, 'TeamArgsFromSchoolRecursive1']


class PaymentIncludeFromSchoolRecursive1(TypedDict, total=False):
    """Relational arguments for School"""
    user: Union[bool, 'UserArgsFromSchoolRecursive2']
    team: Union[bool, 'TeamArgsFromSchoolRecursive2']


class PaymentIncludeFromSchoolRecursive2(TypedDict, total=False):
    """Relational arguments for School"""
    user: Union[bool, 'UserArgsFromSchoolRecursive3']
    team: Union[bool, 'TeamArgsFromSchoolRecursive3']


class PaymentIncludeFromSchoolRecursive3(TypedDict, total=False):
    """Relational arguments for School"""
    user: Union[bool, 'UserArgsFromSchoolRecursive4']
    team: Union[bool, 'TeamArgsFromSchoolRecursive4']


class PaymentIncludeFromSchoolRecursive4(TypedDict, total=False):
    """Relational arguments for School"""

    

class PaymentArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    include: 'PaymentIncludeFromPaymentRecursive1'


class PaymentArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    include: 'PaymentIncludeFromPaymentRecursive2'


class PaymentArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    include: 'PaymentIncludeFromPaymentRecursive3'


class PaymentArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    include: 'PaymentIncludeFromPaymentRecursive4'


class PaymentArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    
    

class FindManyPaymentArgsFromSchool(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive1'


class FindManyPaymentArgsFromSchoolRecursive1(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive2'


class FindManyPaymentArgsFromSchoolRecursive2(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive3'


class FindManyPaymentArgsFromSchoolRecursive3(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive4'


class FindManyPaymentArgsFromSchoolRecursive4(TypedDict, total=False):
    """Arguments for School"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    


FindManySchoolArgs = FindManySchoolArgsFromSchool
FindFirstSchoolArgs = FindManySchoolArgsFromSchool


    

class SchoolWhereInput(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['SchoolWhereInputRecursive1', List['SchoolWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SchoolWhereInputRecursive1']
    OR: List['SchoolWhereInputRecursive1']
    NOT: List['SchoolWhereInputRecursive1']


class SchoolWhereInputRecursive1(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['SchoolWhereInputRecursive2', List['SchoolWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SchoolWhereInputRecursive2']
    OR: List['SchoolWhereInputRecursive2']
    NOT: List['SchoolWhereInputRecursive2']


class SchoolWhereInputRecursive2(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['SchoolWhereInputRecursive3', List['SchoolWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SchoolWhereInputRecursive3']
    OR: List['SchoolWhereInputRecursive3']
    NOT: List['SchoolWhereInputRecursive3']


class SchoolWhereInputRecursive3(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['SchoolWhereInputRecursive4', List['SchoolWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SchoolWhereInputRecursive4']
    OR: List['SchoolWhereInputRecursive4']
    NOT: List['SchoolWhereInputRecursive4']


class SchoolWhereInputRecursive4(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'



# aggregate School types


    

class SchoolScalarWhereWithAggregatesInput(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SchoolScalarWhereWithAggregatesInputRecursive1']
    OR: List['SchoolScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SchoolScalarWhereWithAggregatesInputRecursive1']


class SchoolScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SchoolScalarWhereWithAggregatesInputRecursive2']
    OR: List['SchoolScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SchoolScalarWhereWithAggregatesInputRecursive2']


class SchoolScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SchoolScalarWhereWithAggregatesInputRecursive3']
    OR: List['SchoolScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SchoolScalarWhereWithAggregatesInputRecursive3']


class SchoolScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SchoolScalarWhereWithAggregatesInputRecursive4']
    OR: List['SchoolScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SchoolScalarWhereWithAggregatesInputRecursive4']


class SchoolScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """School arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']



class SchoolGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    _sum: 'SchoolSumAggregateOutput'
    _avg: 'SchoolAvgAggregateOutput'
    _min: 'SchoolMinAggregateOutput'
    _max: 'SchoolMaxAggregateOutput'
    _count: 'SchoolCountAggregateOutput'


class SchoolAvgAggregateOutput(TypedDict, total=False):
    """School output for aggregating averages"""
    id: float


class SchoolSumAggregateOutput(TypedDict, total=False):
    """School output for aggregating sums"""
    id: _int


class SchoolScalarAggregateOutput(TypedDict, total=False):
    """School output including scalar fields"""
    id: _int
    name: _str


SchoolMinAggregateOutput = SchoolScalarAggregateOutput
SchoolMaxAggregateOutput = SchoolScalarAggregateOutput


class SchoolMaxAggregateInput(TypedDict, total=False):
    """School input for aggregating by max"""
    id: bool
    name: bool


class SchoolMinAggregateInput(TypedDict, total=False):
    """School input for aggregating by min"""
    id: bool
    name: bool


class SchoolNumberAggregateInput(TypedDict, total=False):
    """School input for aggregating numbers"""
    id: bool


SchoolAvgAggregateInput = SchoolNumberAggregateInput
SchoolSumAggregateInput = SchoolNumberAggregateInput


SchoolCountAggregateInput = TypedDict(
    'SchoolCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        '_all': bool,
    },
    total=False,
)

SchoolCountAggregateOutput = TypedDict(
    'SchoolCountAggregateOutput',
    {
        'id': int,
        'name': int,
        '_all': int,
    },
    total=False,
)


SchoolKeys = Literal[
    'id',
    'name',
    'users',
    'participants',
    'teams',
]
SchoolScalarFieldKeys = Literal[
    'id',
    'name',
]
SchoolScalarFieldKeysT = TypeVar('SchoolScalarFieldKeysT', bound=SchoolScalarFieldKeys)

SchoolRelationalFieldKeys = Literal[
        'users',
        'participants',
        'teams',
    ]

# GeneralConfig types

class GeneralConfigOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the GeneralConfig create method"""
    id: _int
    canSendEmails: _bool
    mailClient: 'enums.mailClient'


class GeneralConfigCreateInput(GeneralConfigOptionalCreateInput):
    """Required arguments to the GeneralConfig create method"""
    editionYear: _int
    isRegistrationOpen: _bool
    isPaymentOpen: _bool
    expectedRegistrationDate: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class GeneralConfigOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the GeneralConfig create method, without relations"""
    id: _int
    canSendEmails: _bool
    mailClient: 'enums.mailClient'


class GeneralConfigCreateWithoutRelationsInput(GeneralConfigOptionalCreateWithoutRelationsInput):
    """Required arguments to the GeneralConfig create method, without relations"""
    editionYear: _int
    isRegistrationOpen: _bool
    isPaymentOpen: _bool
    expectedRegistrationDate: datetime.datetime


class GeneralConfigCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'GeneralConfigCreateWithoutRelationsInput'
    connect: 'GeneralConfigWhereUniqueInput'


class GeneralConfigCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['GeneralConfigCreateWithoutRelationsInput', List['GeneralConfigCreateWithoutRelationsInput']]
    connect: Union['GeneralConfigWhereUniqueInput', List['GeneralConfigWhereUniqueInput']]


_GeneralConfigWhereUnique_id_Input = TypedDict(
    '_GeneralConfigWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

GeneralConfigWhereUniqueInput = _GeneralConfigWhereUnique_id_Input


class GeneralConfigUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    editionYear: Union[AtomicIntInput, _int]
    isRegistrationOpen: _bool
    isPaymentOpen: _bool
    canSendEmails: _bool
    expectedRegistrationDate: datetime.datetime
    mailClient: 'enums.mailClient'


class GeneralConfigUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    editionYear: Union[AtomicIntInput, _int]
    isRegistrationOpen: _bool
    isPaymentOpen: _bool
    canSendEmails: _bool
    expectedRegistrationDate: datetime.datetime
    mailClient: 'enums.mailClient'


class GeneralConfigUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['GeneralConfigCreateWithoutRelationsInput']
    connect: List['GeneralConfigWhereUniqueInput']
    set: List['GeneralConfigWhereUniqueInput']
    disconnect: List['GeneralConfigWhereUniqueInput']
    delete: List['GeneralConfigWhereUniqueInput']

    # TODO
    # update: List['GeneralConfigUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['GeneralConfigUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['GeneralConfigScalarWhereInput']
    # upsert: List['GeneralConfigUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['GeneralConfigCreateOrConnectWithoutRelationsInput']


class GeneralConfigUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'GeneralConfigCreateWithoutRelationsInput'
    connect: 'GeneralConfigWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'GeneralConfigUpdateInput'
    # upsert: 'GeneralConfigUpsertWithoutRelationsInput'
    # connectOrCreate: 'GeneralConfigCreateOrConnectWithoutRelationsInput'


class GeneralConfigUpsertInput(TypedDict):
    create: 'GeneralConfigCreateInput'
    update: 'GeneralConfigUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_GeneralConfig_id_OrderByInput = TypedDict(
    '_GeneralConfig_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_GeneralConfig_editionYear_OrderByInput = TypedDict(
    '_GeneralConfig_editionYear_OrderByInput',
    {
        'editionYear': 'SortOrder',
    },
    total=True
)

_GeneralConfig_isRegistrationOpen_OrderByInput = TypedDict(
    '_GeneralConfig_isRegistrationOpen_OrderByInput',
    {
        'isRegistrationOpen': 'SortOrder',
    },
    total=True
)

_GeneralConfig_isPaymentOpen_OrderByInput = TypedDict(
    '_GeneralConfig_isPaymentOpen_OrderByInput',
    {
        'isPaymentOpen': 'SortOrder',
    },
    total=True
)

_GeneralConfig_canSendEmails_OrderByInput = TypedDict(
    '_GeneralConfig_canSendEmails_OrderByInput',
    {
        'canSendEmails': 'SortOrder',
    },
    total=True
)

_GeneralConfig_expectedRegistrationDate_OrderByInput = TypedDict(
    '_GeneralConfig_expectedRegistrationDate_OrderByInput',
    {
        'expectedRegistrationDate': 'SortOrder',
    },
    total=True
)

_GeneralConfig_mailClient_OrderByInput = TypedDict(
    '_GeneralConfig_mailClient_OrderByInput',
    {
        'mailClient': 'SortOrder',
    },
    total=True
)

GeneralConfigOrderByInput = Union[
    '_GeneralConfig_id_OrderByInput',
    '_GeneralConfig_editionYear_OrderByInput',
    '_GeneralConfig_isRegistrationOpen_OrderByInput',
    '_GeneralConfig_isPaymentOpen_OrderByInput',
    '_GeneralConfig_canSendEmails_OrderByInput',
    '_GeneralConfig_expectedRegistrationDate_OrderByInput',
    '_GeneralConfig_mailClient_OrderByInput',
]



# recursive GeneralConfig types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

GeneralConfigRelationFilter = TypedDict(
    'GeneralConfigRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class GeneralConfigListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class GeneralConfigInclude(TypedDict, total=False):
    """GeneralConfig relational arguments"""


    

class SportIncludeFromGeneralConfig(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive1']
    admins: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive1']


class SportIncludeFromGeneralConfigRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive2']
    admins: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive2']


class SportIncludeFromGeneralConfigRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive3']
    admins: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive3']


class SportIncludeFromGeneralConfigRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive4']
    admins: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive4']


class SportIncludeFromGeneralConfigRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""

    

class SportArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SportIncludeFromSportRecursive1'


class SportArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SportIncludeFromSportRecursive2'


class SportArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SportIncludeFromSportRecursive3'


class SportArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SportIncludeFromSportRecursive4'


class SportArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    
    

class FindManySportArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive1'


class FindManySportArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive2'


class FindManySportArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive3'


class FindManySportArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive4'


class FindManySportArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    
    

class TeamIncludeFromGeneralConfig(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive1']
    sport: Union[bool, 'SportArgsFromGeneralConfigRecursive1']
    admin: Union[bool, 'UserArgsFromGeneralConfigRecursive1']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive1']


class TeamIncludeFromGeneralConfigRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive2']
    sport: Union[bool, 'SportArgsFromGeneralConfigRecursive2']
    admin: Union[bool, 'UserArgsFromGeneralConfigRecursive2']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive2']


class TeamIncludeFromGeneralConfigRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive3']
    sport: Union[bool, 'SportArgsFromGeneralConfigRecursive3']
    admin: Union[bool, 'UserArgsFromGeneralConfigRecursive3']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive3']


class TeamIncludeFromGeneralConfigRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive4']
    sport: Union[bool, 'SportArgsFromGeneralConfigRecursive4']
    admin: Union[bool, 'UserArgsFromGeneralConfigRecursive4']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive4']


class TeamIncludeFromGeneralConfigRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""

    

class TeamArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    
    

class FindManyTeamArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class UserIncludeFromGeneralConfig(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive1']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive1']
    sportAdmin: Union[bool, 'SportArgsFromGeneralConfigRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive1']


class UserIncludeFromGeneralConfigRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive2']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive2']
    sportAdmin: Union[bool, 'SportArgsFromGeneralConfigRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive2']


class UserIncludeFromGeneralConfigRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive3']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive3']
    sportAdmin: Union[bool, 'SportArgsFromGeneralConfigRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive3']


class UserIncludeFromGeneralConfigRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive4']
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive4']
    sportAdmin: Union[bool, 'SportArgsFromGeneralConfigRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromGeneralConfigRecursive4']


class UserIncludeFromGeneralConfigRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""

    

class UserArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    
    

class FindManyUserArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ParticipantIncludeFromGeneralConfig(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive1']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive1']


class ParticipantIncludeFromGeneralConfigRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive2']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive2']


class ParticipantIncludeFromGeneralConfigRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive3']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive3']


class ParticipantIncludeFromGeneralConfigRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    school: Union[bool, 'SchoolArgsFromGeneralConfigRecursive4']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive4']


class ParticipantIncludeFromGeneralConfigRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""

    

class ParticipantArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    
    

class FindManyParticipantArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class SchoolIncludeFromGeneralConfig(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    users: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive1']


class SchoolIncludeFromGeneralConfigRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    users: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive2']


class SchoolIncludeFromGeneralConfigRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    users: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive3']


class SchoolIncludeFromGeneralConfigRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    users: Union[bool, 'FindManyUserArgsFromGeneralConfigRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromGeneralConfigRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromGeneralConfigRecursive4']


class SchoolIncludeFromGeneralConfigRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""

    

class SchoolArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SchoolIncludeFromSchoolRecursive1'


class SchoolArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SchoolIncludeFromSchoolRecursive2'


class SchoolArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SchoolIncludeFromSchoolRecursive3'


class SchoolArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'SchoolIncludeFromSchoolRecursive4'


class SchoolArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    
    

class FindManySchoolArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive1'


class FindManySchoolArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive2'


class FindManySchoolArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive3'


class FindManySchoolArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive4'


class FindManySchoolArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    
    

class GeneralConfigIncludeFromGeneralConfig(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""


class GeneralConfigIncludeFromGeneralConfigRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""


class GeneralConfigIncludeFromGeneralConfigRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""


class GeneralConfigIncludeFromGeneralConfigRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""


class GeneralConfigIncludeFromGeneralConfigRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""

    

class GeneralConfigArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class GeneralConfigArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class GeneralConfigArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class GeneralConfigArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class GeneralConfigArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    
    

class FindManyGeneralConfigArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class FindManyGeneralConfigArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class FindManyGeneralConfigArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class FindManyGeneralConfigArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class FindManyGeneralConfigArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    
    

class PaymentIncludeFromGeneralConfig(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    user: Union[bool, 'UserArgsFromGeneralConfigRecursive1']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive1']


class PaymentIncludeFromGeneralConfigRecursive1(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    user: Union[bool, 'UserArgsFromGeneralConfigRecursive2']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive2']


class PaymentIncludeFromGeneralConfigRecursive2(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    user: Union[bool, 'UserArgsFromGeneralConfigRecursive3']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive3']


class PaymentIncludeFromGeneralConfigRecursive3(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""
    user: Union[bool, 'UserArgsFromGeneralConfigRecursive4']
    team: Union[bool, 'TeamArgsFromGeneralConfigRecursive4']


class PaymentIncludeFromGeneralConfigRecursive4(TypedDict, total=False):
    """Relational arguments for GeneralConfig"""

    

class PaymentArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'PaymentIncludeFromPaymentRecursive1'


class PaymentArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'PaymentIncludeFromPaymentRecursive2'


class PaymentArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'PaymentIncludeFromPaymentRecursive3'


class PaymentArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    include: 'PaymentIncludeFromPaymentRecursive4'


class PaymentArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    
    

class FindManyPaymentArgsFromGeneralConfig(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive1'


class FindManyPaymentArgsFromGeneralConfigRecursive1(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive2'


class FindManyPaymentArgsFromGeneralConfigRecursive2(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive3'


class FindManyPaymentArgsFromGeneralConfigRecursive3(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive4'


class FindManyPaymentArgsFromGeneralConfigRecursive4(TypedDict, total=False):
    """Arguments for GeneralConfig"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    


FindManyGeneralConfigArgs = FindManyGeneralConfigArgsFromGeneralConfig
FindFirstGeneralConfigArgs = FindManyGeneralConfigArgsFromGeneralConfig


    

class GeneralConfigWhereInput(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    editionYear: Union[_int, 'types.IntFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanFilter']
    canSendEmails: Union[_bool, 'types.BooleanFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeFilter']
    mailClient: 'enums.mailClient'

    # should be noted that AND and NOT should be Union['GeneralConfigWhereInputRecursive1', List['GeneralConfigWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['GeneralConfigWhereInputRecursive1']
    OR: List['GeneralConfigWhereInputRecursive1']
    NOT: List['GeneralConfigWhereInputRecursive1']


class GeneralConfigWhereInputRecursive1(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    editionYear: Union[_int, 'types.IntFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanFilter']
    canSendEmails: Union[_bool, 'types.BooleanFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeFilter']
    mailClient: 'enums.mailClient'

    # should be noted that AND and NOT should be Union['GeneralConfigWhereInputRecursive2', List['GeneralConfigWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['GeneralConfigWhereInputRecursive2']
    OR: List['GeneralConfigWhereInputRecursive2']
    NOT: List['GeneralConfigWhereInputRecursive2']


class GeneralConfigWhereInputRecursive2(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    editionYear: Union[_int, 'types.IntFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanFilter']
    canSendEmails: Union[_bool, 'types.BooleanFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeFilter']
    mailClient: 'enums.mailClient'

    # should be noted that AND and NOT should be Union['GeneralConfigWhereInputRecursive3', List['GeneralConfigWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['GeneralConfigWhereInputRecursive3']
    OR: List['GeneralConfigWhereInputRecursive3']
    NOT: List['GeneralConfigWhereInputRecursive3']


class GeneralConfigWhereInputRecursive3(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    editionYear: Union[_int, 'types.IntFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanFilter']
    canSendEmails: Union[_bool, 'types.BooleanFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeFilter']
    mailClient: 'enums.mailClient'

    # should be noted that AND and NOT should be Union['GeneralConfigWhereInputRecursive4', List['GeneralConfigWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['GeneralConfigWhereInputRecursive4']
    OR: List['GeneralConfigWhereInputRecursive4']
    NOT: List['GeneralConfigWhereInputRecursive4']


class GeneralConfigWhereInputRecursive4(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    editionYear: Union[_int, 'types.IntFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanFilter']
    canSendEmails: Union[_bool, 'types.BooleanFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeFilter']
    mailClient: 'enums.mailClient'



# aggregate GeneralConfig types


    

class GeneralConfigScalarWhereWithAggregatesInput(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    editionYear: Union[_int, 'types.IntWithAggregatesFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    canSendEmails: Union[_bool, 'types.BooleanWithAggregatesFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    mailClient: 'enums.mailClient'

    AND: List['GeneralConfigScalarWhereWithAggregatesInputRecursive1']
    OR: List['GeneralConfigScalarWhereWithAggregatesInputRecursive1']
    NOT: List['GeneralConfigScalarWhereWithAggregatesInputRecursive1']


class GeneralConfigScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    editionYear: Union[_int, 'types.IntWithAggregatesFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    canSendEmails: Union[_bool, 'types.BooleanWithAggregatesFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    mailClient: 'enums.mailClient'

    AND: List['GeneralConfigScalarWhereWithAggregatesInputRecursive2']
    OR: List['GeneralConfigScalarWhereWithAggregatesInputRecursive2']
    NOT: List['GeneralConfigScalarWhereWithAggregatesInputRecursive2']


class GeneralConfigScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    editionYear: Union[_int, 'types.IntWithAggregatesFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    canSendEmails: Union[_bool, 'types.BooleanWithAggregatesFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    mailClient: 'enums.mailClient'

    AND: List['GeneralConfigScalarWhereWithAggregatesInputRecursive3']
    OR: List['GeneralConfigScalarWhereWithAggregatesInputRecursive3']
    NOT: List['GeneralConfigScalarWhereWithAggregatesInputRecursive3']


class GeneralConfigScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    editionYear: Union[_int, 'types.IntWithAggregatesFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    canSendEmails: Union[_bool, 'types.BooleanWithAggregatesFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    mailClient: 'enums.mailClient'

    AND: List['GeneralConfigScalarWhereWithAggregatesInputRecursive4']
    OR: List['GeneralConfigScalarWhereWithAggregatesInputRecursive4']
    NOT: List['GeneralConfigScalarWhereWithAggregatesInputRecursive4']


class GeneralConfigScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """GeneralConfig arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    editionYear: Union[_int, 'types.IntWithAggregatesFilter']
    isRegistrationOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isPaymentOpen: Union[_bool, 'types.BooleanWithAggregatesFilter']
    canSendEmails: Union[_bool, 'types.BooleanWithAggregatesFilter']
    expectedRegistrationDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    mailClient: 'enums.mailClient'



class GeneralConfigGroupByOutput(TypedDict, total=False):
    id: _int
    editionYear: _int
    isRegistrationOpen: _bool
    isPaymentOpen: _bool
    canSendEmails: _bool
    expectedRegistrationDate: datetime.datetime
    mailClient: 'enums.mailClient'
    _sum: 'GeneralConfigSumAggregateOutput'
    _avg: 'GeneralConfigAvgAggregateOutput'
    _min: 'GeneralConfigMinAggregateOutput'
    _max: 'GeneralConfigMaxAggregateOutput'
    _count: 'GeneralConfigCountAggregateOutput'


class GeneralConfigAvgAggregateOutput(TypedDict, total=False):
    """GeneralConfig output for aggregating averages"""
    id: float
    editionYear: float


class GeneralConfigSumAggregateOutput(TypedDict, total=False):
    """GeneralConfig output for aggregating sums"""
    id: _int
    editionYear: _int


class GeneralConfigScalarAggregateOutput(TypedDict, total=False):
    """GeneralConfig output including scalar fields"""
    id: _int
    editionYear: _int
    isRegistrationOpen: _bool
    isPaymentOpen: _bool
    canSendEmails: _bool
    expectedRegistrationDate: datetime.datetime
    mailClient: 'enums.mailClient'


GeneralConfigMinAggregateOutput = GeneralConfigScalarAggregateOutput
GeneralConfigMaxAggregateOutput = GeneralConfigScalarAggregateOutput


class GeneralConfigMaxAggregateInput(TypedDict, total=False):
    """GeneralConfig input for aggregating by max"""
    id: bool
    editionYear: bool
    isRegistrationOpen: bool
    isPaymentOpen: bool
    canSendEmails: bool
    expectedRegistrationDate: bool
    mailClient: bool


class GeneralConfigMinAggregateInput(TypedDict, total=False):
    """GeneralConfig input for aggregating by min"""
    id: bool
    editionYear: bool
    isRegistrationOpen: bool
    isPaymentOpen: bool
    canSendEmails: bool
    expectedRegistrationDate: bool
    mailClient: bool


class GeneralConfigNumberAggregateInput(TypedDict, total=False):
    """GeneralConfig input for aggregating numbers"""
    id: bool
    editionYear: bool


GeneralConfigAvgAggregateInput = GeneralConfigNumberAggregateInput
GeneralConfigSumAggregateInput = GeneralConfigNumberAggregateInput


GeneralConfigCountAggregateInput = TypedDict(
    'GeneralConfigCountAggregateInput',
    {
        'id': bool,
        'editionYear': bool,
        'isRegistrationOpen': bool,
        'isPaymentOpen': bool,
        'canSendEmails': bool,
        'expectedRegistrationDate': bool,
        'mailClient': bool,
        '_all': bool,
    },
    total=False,
)

GeneralConfigCountAggregateOutput = TypedDict(
    'GeneralConfigCountAggregateOutput',
    {
        'id': int,
        'editionYear': int,
        'isRegistrationOpen': int,
        'isPaymentOpen': int,
        'canSendEmails': int,
        'expectedRegistrationDate': int,
        'mailClient': int,
        '_all': int,
    },
    total=False,
)


GeneralConfigKeys = Literal[
    'id',
    'editionYear',
    'isRegistrationOpen',
    'isPaymentOpen',
    'canSendEmails',
    'expectedRegistrationDate',
    'mailClient',
]
GeneralConfigScalarFieldKeys = Literal[
    'id',
    'editionYear',
    'isRegistrationOpen',
    'isPaymentOpen',
    'canSendEmails',
    'expectedRegistrationDate',
    'mailClient',
]
GeneralConfigScalarFieldKeysT = TypeVar('GeneralConfigScalarFieldKeysT', bound=GeneralConfigScalarFieldKeys)

GeneralConfigRelationalFieldKeys = _NoneType

# Payment types

class PaymentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Payment create method"""
    id: _int
    createdAt: datetime.datetime
    userId: _int
    user: 'UserCreateNestedWithoutRelationsInput'
    teamId: _int
    team: 'TeamCreateNestedWithoutRelationsInput'
    requestId: Optional[_str]
    requestUuid: Optional[_str]


class PaymentCreateInput(PaymentOptionalCreateInput):
    """Required arguments to the Payment create method"""
    amountInCents: _int
    paymentStatus: 'enums.PaymentStatus'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PaymentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Payment create method, without relations"""
    id: _int
    createdAt: datetime.datetime
    userId: _int
    teamId: _int
    requestId: Optional[_str]
    requestUuid: Optional[_str]


class PaymentCreateWithoutRelationsInput(PaymentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Payment create method, without relations"""
    amountInCents: _int
    paymentStatus: 'enums.PaymentStatus'


class PaymentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentCreateWithoutRelationsInput'
    connect: 'PaymentWhereUniqueInput'


class PaymentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PaymentCreateWithoutRelationsInput', List['PaymentCreateWithoutRelationsInput']]
    connect: Union['PaymentWhereUniqueInput', List['PaymentWhereUniqueInput']]


_PaymentWhereUnique_id_Input = TypedDict(
    '_PaymentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

PaymentWhereUniqueInput = _PaymentWhereUnique_id_Input


class PaymentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    amountInCents: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    team: 'TeamUpdateOneWithoutRelationsInput'
    paymentStatus: 'enums.PaymentStatus'
    requestId: Optional[_str]
    requestUuid: Optional[_str]


class PaymentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    amountInCents: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    paymentStatus: 'enums.PaymentStatus'
    requestId: Optional[_str]
    requestUuid: Optional[_str]


class PaymentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PaymentCreateWithoutRelationsInput']
    connect: List['PaymentWhereUniqueInput']
    set: List['PaymentWhereUniqueInput']
    disconnect: List['PaymentWhereUniqueInput']
    delete: List['PaymentWhereUniqueInput']

    # TODO
    # update: List['PaymentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PaymentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PaymentScalarWhereInput']
    # upsert: List['PaymentUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PaymentCreateOrConnectWithoutRelationsInput']


class PaymentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentCreateWithoutRelationsInput'
    connect: 'PaymentWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PaymentUpdateInput'
    # upsert: 'PaymentUpsertWithoutRelationsInput'
    # connectOrCreate: 'PaymentCreateOrConnectWithoutRelationsInput'


class PaymentUpsertInput(TypedDict):
    create: 'PaymentCreateInput'
    update: 'PaymentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Payment_id_OrderByInput = TypedDict(
    '_Payment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Payment_amountInCents_OrderByInput = TypedDict(
    '_Payment_amountInCents_OrderByInput',
    {
        'amountInCents': 'SortOrder',
    },
    total=True
)

_Payment_createdAt_OrderByInput = TypedDict(
    '_Payment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Payment_userId_OrderByInput = TypedDict(
    '_Payment_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Payment_teamId_OrderByInput = TypedDict(
    '_Payment_teamId_OrderByInput',
    {
        'teamId': 'SortOrder',
    },
    total=True
)

_Payment_paymentStatus_OrderByInput = TypedDict(
    '_Payment_paymentStatus_OrderByInput',
    {
        'paymentStatus': 'SortOrder',
    },
    total=True
)

_Payment_requestId_OrderByInput = TypedDict(
    '_Payment_requestId_OrderByInput',
    {
        'requestId': 'SortOrder',
    },
    total=True
)

_Payment_requestUuid_OrderByInput = TypedDict(
    '_Payment_requestUuid_OrderByInput',
    {
        'requestUuid': 'SortOrder',
    },
    total=True
)

PaymentOrderByInput = Union[
    '_Payment_id_OrderByInput',
    '_Payment_amountInCents_OrderByInput',
    '_Payment_createdAt_OrderByInput',
    '_Payment_userId_OrderByInput',
    '_Payment_teamId_OrderByInput',
    '_Payment_paymentStatus_OrderByInput',
    '_Payment_requestId_OrderByInput',
    '_Payment_requestUuid_OrderByInput',
]



# recursive Payment types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PaymentRelationFilter = TypedDict(
    'PaymentRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PaymentListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PaymentInclude(TypedDict, total=False):
    """Payment relational arguments"""
    user: Union[bool, 'UserArgsFromPayment']
    team: Union[bool, 'TeamArgsFromPayment']


    

class SportIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive1']
    admins: Union[bool, 'FindManyUserArgsFromPaymentRecursive1']


class SportIncludeFromPaymentRecursive1(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive2']
    admins: Union[bool, 'FindManyUserArgsFromPaymentRecursive2']


class SportIncludeFromPaymentRecursive2(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive3']
    admins: Union[bool, 'FindManyUserArgsFromPaymentRecursive3']


class SportIncludeFromPaymentRecursive3(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive4']
    admins: Union[bool, 'FindManyUserArgsFromPaymentRecursive4']


class SportIncludeFromPaymentRecursive4(TypedDict, total=False):
    """Relational arguments for Payment"""

    

class SportArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SportIncludeFromSportRecursive1'


class SportArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SportIncludeFromSportRecursive2'


class SportArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SportIncludeFromSportRecursive3'


class SportArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SportIncludeFromSportRecursive4'


class SportArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    
    

class FindManySportArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive1'


class FindManySportArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive2'


class FindManySportArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive3'


class FindManySportArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    include: 'SportIncludeFromSportRecursive4'


class FindManySportArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SportOrderByInput', List['SportOrderByInput']]
    where: 'SportWhereInput'
    cursor: 'SportWhereUniqueInput'
    distinct: List['SportScalarFieldKeys']
    
    

class TeamIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive1']
    sport: Union[bool, 'SportArgsFromPaymentRecursive1']
    admin: Union[bool, 'UserArgsFromPaymentRecursive1']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive1']


class TeamIncludeFromPaymentRecursive1(TypedDict, total=False):
    """Relational arguments for Payment"""
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive2']
    sport: Union[bool, 'SportArgsFromPaymentRecursive2']
    admin: Union[bool, 'UserArgsFromPaymentRecursive2']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive2']


class TeamIncludeFromPaymentRecursive2(TypedDict, total=False):
    """Relational arguments for Payment"""
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive3']
    sport: Union[bool, 'SportArgsFromPaymentRecursive3']
    admin: Union[bool, 'UserArgsFromPaymentRecursive3']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive3']


class TeamIncludeFromPaymentRecursive3(TypedDict, total=False):
    """Relational arguments for Payment"""
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive4']
    sport: Union[bool, 'SportArgsFromPaymentRecursive4']
    admin: Union[bool, 'UserArgsFromPaymentRecursive4']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive4']


class TeamIncludeFromPaymentRecursive4(TypedDict, total=False):
    """Relational arguments for Payment"""

    

class TeamArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    
    

class FindManyTeamArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class UserIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive1']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive1']
    sportAdmin: Union[bool, 'SportArgsFromPaymentRecursive1']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive1']


class UserIncludeFromPaymentRecursive1(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive2']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive2']
    sportAdmin: Union[bool, 'SportArgsFromPaymentRecursive2']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive2']


class UserIncludeFromPaymentRecursive2(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive3']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive3']
    sportAdmin: Union[bool, 'SportArgsFromPaymentRecursive3']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive3']


class UserIncludeFromPaymentRecursive3(TypedDict, total=False):
    """Relational arguments for Payment"""
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive4']
    school: Union[bool, 'SchoolArgsFromPaymentRecursive4']
    sportAdmin: Union[bool, 'SportArgsFromPaymentRecursive4']
    Payment: Union[bool, 'FindManyPaymentArgsFromPaymentRecursive4']


class UserIncludeFromPaymentRecursive4(TypedDict, total=False):
    """Relational arguments for Payment"""

    

class UserArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    
    

class FindManyUserArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class ParticipantIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    school: Union[bool, 'SchoolArgsFromPaymentRecursive1']
    team: Union[bool, 'TeamArgsFromPaymentRecursive1']


class ParticipantIncludeFromPaymentRecursive1(TypedDict, total=False):
    """Relational arguments for Payment"""
    school: Union[bool, 'SchoolArgsFromPaymentRecursive2']
    team: Union[bool, 'TeamArgsFromPaymentRecursive2']


class ParticipantIncludeFromPaymentRecursive2(TypedDict, total=False):
    """Relational arguments for Payment"""
    school: Union[bool, 'SchoolArgsFromPaymentRecursive3']
    team: Union[bool, 'TeamArgsFromPaymentRecursive3']


class ParticipantIncludeFromPaymentRecursive3(TypedDict, total=False):
    """Relational arguments for Payment"""
    school: Union[bool, 'SchoolArgsFromPaymentRecursive4']
    team: Union[bool, 'TeamArgsFromPaymentRecursive4']


class ParticipantIncludeFromPaymentRecursive4(TypedDict, total=False):
    """Relational arguments for Payment"""

    

class ParticipantArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    
    

class FindManyParticipantArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class SchoolIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    users: Union[bool, 'FindManyUserArgsFromPaymentRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive1']


class SchoolIncludeFromPaymentRecursive1(TypedDict, total=False):
    """Relational arguments for Payment"""
    users: Union[bool, 'FindManyUserArgsFromPaymentRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive2']


class SchoolIncludeFromPaymentRecursive2(TypedDict, total=False):
    """Relational arguments for Payment"""
    users: Union[bool, 'FindManyUserArgsFromPaymentRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive3']


class SchoolIncludeFromPaymentRecursive3(TypedDict, total=False):
    """Relational arguments for Payment"""
    users: Union[bool, 'FindManyUserArgsFromPaymentRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromPaymentRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromPaymentRecursive4']


class SchoolIncludeFromPaymentRecursive4(TypedDict, total=False):
    """Relational arguments for Payment"""

    

class SchoolArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SchoolIncludeFromSchoolRecursive1'


class SchoolArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SchoolIncludeFromSchoolRecursive2'


class SchoolArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SchoolIncludeFromSchoolRecursive3'


class SchoolArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SchoolIncludeFromSchoolRecursive4'


class SchoolArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    
    

class FindManySchoolArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive1'


class FindManySchoolArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive2'


class FindManySchoolArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive3'


class FindManySchoolArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    include: 'SchoolIncludeFromSchoolRecursive4'


class FindManySchoolArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SchoolOrderByInput', List['SchoolOrderByInput']]
    where: 'SchoolWhereInput'
    cursor: 'SchoolWhereUniqueInput'
    distinct: List['SchoolScalarFieldKeys']
    
    

class GeneralConfigIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""


class GeneralConfigIncludeFromPaymentRecursive1(TypedDict, total=False):
    """Relational arguments for Payment"""


class GeneralConfigIncludeFromPaymentRecursive2(TypedDict, total=False):
    """Relational arguments for Payment"""


class GeneralConfigIncludeFromPaymentRecursive3(TypedDict, total=False):
    """Relational arguments for Payment"""


class GeneralConfigIncludeFromPaymentRecursive4(TypedDict, total=False):
    """Relational arguments for Payment"""

    

class GeneralConfigArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class GeneralConfigArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class GeneralConfigArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class GeneralConfigArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class GeneralConfigArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    
    

class FindManyGeneralConfigArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive1'


class FindManyGeneralConfigArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive2'


class FindManyGeneralConfigArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive3'


class FindManyGeneralConfigArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    include: 'GeneralConfigIncludeFromGeneralConfigRecursive4'


class FindManyGeneralConfigArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['GeneralConfigOrderByInput', List['GeneralConfigOrderByInput']]
    where: 'GeneralConfigWhereInput'
    cursor: 'GeneralConfigWhereUniqueInput'
    distinct: List['GeneralConfigScalarFieldKeys']
    
    

class PaymentIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPaymentRecursive1']
    team: Union[bool, 'TeamArgsFromPaymentRecursive1']


class PaymentIncludeFromPaymentRecursive1(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPaymentRecursive2']
    team: Union[bool, 'TeamArgsFromPaymentRecursive2']


class PaymentIncludeFromPaymentRecursive2(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPaymentRecursive3']
    team: Union[bool, 'TeamArgsFromPaymentRecursive3']


class PaymentIncludeFromPaymentRecursive3(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPaymentRecursive4']
    team: Union[bool, 'TeamArgsFromPaymentRecursive4']


class PaymentIncludeFromPaymentRecursive4(TypedDict, total=False):
    """Relational arguments for Payment"""

    

class PaymentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'PaymentIncludeFromPaymentRecursive1'


class PaymentArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'PaymentIncludeFromPaymentRecursive2'


class PaymentArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'PaymentIncludeFromPaymentRecursive3'


class PaymentArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'PaymentIncludeFromPaymentRecursive4'


class PaymentArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    
    

class FindManyPaymentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive1'


class FindManyPaymentArgsFromPaymentRecursive1(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive2'


class FindManyPaymentArgsFromPaymentRecursive2(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive3'


class FindManyPaymentArgsFromPaymentRecursive3(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPaymentRecursive4'


class FindManyPaymentArgsFromPaymentRecursive4(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    


FindManyPaymentArgs = FindManyPaymentArgsFromPayment
FindFirstPaymentArgs = FindManyPaymentArgsFromPayment


    

class PaymentWhereInput(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    amountInCents: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    userId: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[None, _str, 'types.StringFilter']
    requestUuid: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PaymentWhereInputRecursive1', List['PaymentWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PaymentWhereInputRecursive1']
    OR: List['PaymentWhereInputRecursive1']
    NOT: List['PaymentWhereInputRecursive1']


class PaymentWhereInputRecursive1(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    amountInCents: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    userId: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[None, _str, 'types.StringFilter']
    requestUuid: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PaymentWhereInputRecursive2', List['PaymentWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PaymentWhereInputRecursive2']
    OR: List['PaymentWhereInputRecursive2']
    NOT: List['PaymentWhereInputRecursive2']


class PaymentWhereInputRecursive2(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    amountInCents: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    userId: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[None, _str, 'types.StringFilter']
    requestUuid: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PaymentWhereInputRecursive3', List['PaymentWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['PaymentWhereInputRecursive3']
    OR: List['PaymentWhereInputRecursive3']
    NOT: List['PaymentWhereInputRecursive3']


class PaymentWhereInputRecursive3(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    amountInCents: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    userId: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[None, _str, 'types.StringFilter']
    requestUuid: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['PaymentWhereInputRecursive4', List['PaymentWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['PaymentWhereInputRecursive4']
    OR: List['PaymentWhereInputRecursive4']
    NOT: List['PaymentWhereInputRecursive4']


class PaymentWhereInputRecursive4(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    amountInCents: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    userId: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    teamId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[None, _str, 'types.StringFilter']
    requestUuid: Union[None, _str, 'types.StringFilter']



# aggregate Payment types


    

class PaymentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    amountInCents: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[_str, 'types.StringWithAggregatesFilter']
    requestUuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PaymentScalarWhereWithAggregatesInputRecursive1']
    OR: List['PaymentScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PaymentScalarWhereWithAggregatesInputRecursive1']


class PaymentScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    amountInCents: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[_str, 'types.StringWithAggregatesFilter']
    requestUuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PaymentScalarWhereWithAggregatesInputRecursive2']
    OR: List['PaymentScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PaymentScalarWhereWithAggregatesInputRecursive2']


class PaymentScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    amountInCents: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[_str, 'types.StringWithAggregatesFilter']
    requestUuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PaymentScalarWhereWithAggregatesInputRecursive3']
    OR: List['PaymentScalarWhereWithAggregatesInputRecursive3']
    NOT: List['PaymentScalarWhereWithAggregatesInputRecursive3']


class PaymentScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    amountInCents: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[_str, 'types.StringWithAggregatesFilter']
    requestUuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PaymentScalarWhereWithAggregatesInputRecursive4']
    OR: List['PaymentScalarWhereWithAggregatesInputRecursive4']
    NOT: List['PaymentScalarWhereWithAggregatesInputRecursive4']


class PaymentScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    amountInCents: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    paymentStatus: 'enums.PaymentStatus'
    requestId: Union[_str, 'types.StringWithAggregatesFilter']
    requestUuid: Union[_str, 'types.StringWithAggregatesFilter']



class PaymentGroupByOutput(TypedDict, total=False):
    id: _int
    amountInCents: _int
    createdAt: datetime.datetime
    userId: _int
    teamId: _int
    paymentStatus: 'enums.PaymentStatus'
    requestId: _str
    requestUuid: _str
    _sum: 'PaymentSumAggregateOutput'
    _avg: 'PaymentAvgAggregateOutput'
    _min: 'PaymentMinAggregateOutput'
    _max: 'PaymentMaxAggregateOutput'
    _count: 'PaymentCountAggregateOutput'


class PaymentAvgAggregateOutput(TypedDict, total=False):
    """Payment output for aggregating averages"""
    id: float
    amountInCents: float
    userId: float
    teamId: float


class PaymentSumAggregateOutput(TypedDict, total=False):
    """Payment output for aggregating sums"""
    id: _int
    amountInCents: _int
    userId: _int
    teamId: _int


class PaymentScalarAggregateOutput(TypedDict, total=False):
    """Payment output including scalar fields"""
    id: _int
    amountInCents: _int
    createdAt: datetime.datetime
    userId: _int
    teamId: _int
    paymentStatus: 'enums.PaymentStatus'
    requestId: _str
    requestUuid: _str


PaymentMinAggregateOutput = PaymentScalarAggregateOutput
PaymentMaxAggregateOutput = PaymentScalarAggregateOutput


class PaymentMaxAggregateInput(TypedDict, total=False):
    """Payment input for aggregating by max"""
    id: bool
    amountInCents: bool
    createdAt: bool
    userId: bool
    teamId: bool
    paymentStatus: bool
    requestId: bool
    requestUuid: bool


class PaymentMinAggregateInput(TypedDict, total=False):
    """Payment input for aggregating by min"""
    id: bool
    amountInCents: bool
    createdAt: bool
    userId: bool
    teamId: bool
    paymentStatus: bool
    requestId: bool
    requestUuid: bool


class PaymentNumberAggregateInput(TypedDict, total=False):
    """Payment input for aggregating numbers"""
    id: bool
    amountInCents: bool
    userId: bool
    teamId: bool


PaymentAvgAggregateInput = PaymentNumberAggregateInput
PaymentSumAggregateInput = PaymentNumberAggregateInput


PaymentCountAggregateInput = TypedDict(
    'PaymentCountAggregateInput',
    {
        'id': bool,
        'amountInCents': bool,
        'createdAt': bool,
        'userId': bool,
        'teamId': bool,
        'paymentStatus': bool,
        'requestId': bool,
        'requestUuid': bool,
        '_all': bool,
    },
    total=False,
)

PaymentCountAggregateOutput = TypedDict(
    'PaymentCountAggregateOutput',
    {
        'id': int,
        'amountInCents': int,
        'createdAt': int,
        'userId': int,
        'teamId': int,
        'paymentStatus': int,
        'requestId': int,
        'requestUuid': int,
        '_all': int,
    },
    total=False,
)


PaymentKeys = Literal[
    'id',
    'amountInCents',
    'createdAt',
    'userId',
    'user',
    'teamId',
    'team',
    'paymentStatus',
    'requestId',
    'requestUuid',
]
PaymentScalarFieldKeys = Literal[
    'id',
    'amountInCents',
    'createdAt',
    'userId',
    'teamId',
    'paymentStatus',
    'requestId',
    'requestUuid',
]
PaymentScalarFieldKeysT = TypeVar('PaymentScalarFieldKeysT', bound=PaymentScalarFieldKeys)

PaymentRelationalFieldKeys = Literal[
        'user',
        'team',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields