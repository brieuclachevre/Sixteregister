# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class SportActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Sport]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Sport.prisma().query_raw(
            'SELECT * FROM Sport WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Sport
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Sport.prisma().query_first(
            'SELECT * FROM Sport WHERE sport = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SportCreateInput,
        include: Optional[types.SportInclude] = None
    ) -> _PrismaModelT:
        """Create a new Sport record.

        Parameters
        ----------
        data
            Sport record data
        include
            Specifies which relations should be loaded on the returned Sport model

        Returns
        -------
        prisma.models.Sport
            The created Sport record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Sport record from just the required fields
        sport = await Sport.prisma().create(
            data={
                # data to create a Sport record
                'sport': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SportCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Sport records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Sport record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Sport.prisma().create_many(
            data=[
                {
                    # data to create a Sport record
                    'sport': 'bbehjachib',
                },
                {
                    # data to create a Sport record
                    'sport': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SportWhereUniqueInput,
        include: Optional[types.SportInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Sport record.

        Parameters
        ----------
        where
            Sport filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Sport model

        Returns
        -------
        prisma.models.Sport
            The deleted Sport record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sport = await Sport.prisma().delete(
            where={
                'id': 368800899,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SportWhereUniqueInput,
        include: Optional[types.SportInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Sport record.

        Parameters
        ----------
        where
            Sport filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Sport model

        Returns
        -------
        prisma.models.Sport
            The found Sport record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sport = await Sport.prisma().find_unique(
            where={
                'id': 1508029952,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SportWhereUniqueInput,
        include: Optional[types.SportInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Sport record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Sport filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Sport model

        Returns
        -------
        prisma.models.Sport
            The found Sport record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sport = await Sport.prisma().find_unique_or_raise(
            where={
                'id': 486256185,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SportWhereInput] = None,
        cursor: Optional[types.SportWhereUniqueInput] = None,
        include: Optional[types.SportInclude] = None,
        order: Optional[Union[types.SportOrderByInput, List[types.SportOrderByInput]]] = None,
        distinct: Optional[List[types.SportScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Sport records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Sport records returned
        skip
            Ignore the first N results
        where
            Sport filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Sport model
        order
            Order the returned Sport records by any field
        distinct
            Filter Sport records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Sport]
            The list of all Sport records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Sport records
        sports = await Sport.prisma().find_many(take=10)

        # find the first 5 Sport records ordered by the nbPlayersMin field
        sports = await Sport.prisma().find_many(
            take=5,
            order={
                'nbPlayersMin': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SportWhereInput] = None,
        cursor: Optional[types.SportWhereUniqueInput] = None,
        include: Optional[types.SportInclude] = None,
        order: Optional[Union[types.SportOrderByInput, List[types.SportOrderByInput]]] = None,
        distinct: Optional[List[types.SportScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Sport record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Sport filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Sport model
        order
            Order the returned Sport records by any field
        distinct
            Filter Sport records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Sport
            The first Sport record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Sport record ordered by the nbPlayersMax field
        sport = await Sport.prisma().find_first(
            skip=1,
            order={
                'nbPlayersMax': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SportWhereInput] = None,
        cursor: Optional[types.SportWhereUniqueInput] = None,
        include: Optional[types.SportInclude] = None,
        order: Optional[Union[types.SportOrderByInput, List[types.SportOrderByInput]]] = None,
        distinct: Optional[List[types.SportScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Sport record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Sport filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Sport model
        order
            Order the returned Sport records by any field
        distinct
            Filter Sport records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Sport
            The first Sport record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Sport record ordered by the isCollective field
        sport = await Sport.prisma().find_first_or_raise(
            skip=1,
            order={
                'isCollective': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SportUpdateInput,
        where: types.SportWhereUniqueInput,
        include: Optional[types.SportInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Sport record.

        Parameters
        ----------
        data
            Sport record data specifying what to update
        where
            Sport filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Sport model

        Returns
        -------
        prisma.models.Sport
            The updated Sport record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        sport = await Sport.prisma().update(
            where={
                'id': 1062517886,
            },
            data={
                # data to update the Sport record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SportWhereUniqueInput,
        data: types.SportUpsertInput,
        include: Optional[types.SportInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Sport filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Sport model

        Returns
        -------
        prisma.models.Sport
            The created or updated Sport record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sport = await Sport.prisma().upsert(
            where={
                'id': 267834847,
            },
            data={
                'create': {
                    'id': 267834847,
                    'sport': 'cadfabfehe',
                },
                'update': {
                    'sport': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SportUpdateManyMutationInput,
        where: types.SportWhereInput,
    ) -> int:
        """Update multiple Sport records

        Parameters
        ----------
        data
            Sport data to update the selected Sport records to
        where
            Filter to select the Sport records to update

        Returns
        -------
        int
            The total number of Sport records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Sport records
        total = await Sport.prisma().update_many(
            data={
                'nbOfTeams': 180171308
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SportWhereInput] = None,
        cursor: Optional[types.SportWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Sport records present in the database

        Parameters
        ----------
        select
            Select the Sport fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Sport filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SportCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Sport.prisma().count()

        # results: prisma.types.SportCountAggregateOutput
        results = await Sport.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SportCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SportWhereInput] = None,
        cursor: Optional[types.SportWhereUniqueInput] = None,
    ) -> types.SportCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SportCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SportWhereInput] = None,
        cursor: Optional[types.SportWhereUniqueInput] = None,
    ) -> Union[int, types.SportCountAggregateOutput]:
        """Count the number of Sport records present in the database

        Parameters
        ----------
        select
            Select the Sport fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Sport filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SportCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Sport.prisma().count()

        # results: prisma.types.SportCountAggregateOutput
        results = await Sport.prisma().count(
            select={
                '_all': True,
                'sport': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SportCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SportWhereInput] = None
    ) -> int:
        """Delete multiple Sport records.

        Parameters
        ----------
        where
            Optional Sport filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Sport records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Sport records
        total = await Sport.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SportScalarFieldKeys'],
        *,
        where: Optional['types.SportWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SportAvgAggregateInput'] = None,
        sum: Optional['types.SportSumAggregateInput'] = None,
        min: Optional['types.SportMinAggregateInput'] = None,
        max: Optional['types.SportMaxAggregateInput'] = None,
        having: Optional['types.SportScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SportCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SportScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SportScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SportGroupByOutput']:
        """Group Sport records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Sport fields to group records by
        where
            Sport filter to select records
        take
            Limit the maximum number of Sport records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SportGroupByOutput]
            A list of dictionaries representing the Sport record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Sport records by nbPlayersMin values
        # and count how many records are in each group
        results = await Sport.prisma().group_by(
            ['nbPlayersMin'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Team]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Team.prisma().query_raw(
            'SELECT * FROM Team WHERE id = $1',
            836760821,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Team
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Team.prisma().query_first(
            'SELECT * FROM Team WHERE name = $1',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TeamCreateInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Create a new Team record.

        Parameters
        ----------
        data
            Team record data
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created Team record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Team record from just the required fields
        team = await Team.prisma().create(
            data={
                # data to create a Team record
                'name': 'hjaecfifb',
                'status': enums.TeamStatus.Waiting,
                'sportId': 2111915288,
                'teamAdminUserId': 1149758321,
                'schoolId': 1644289366,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TeamCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Team records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Team record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Team.prisma().create_many(
            data=[
                {
                    # data to create a Team record
                    'name': 'bdiicjafbj',
                    'status': enums.TeamStatus.Waiting,
                    'sportId': 1647418052,
                    'teamAdminUserId': 1675546029,
                    'schoolId': 1767274722,
                },
                {
                    # data to create a Team record
                    'name': 'dcgchcbbf',
                    'status': enums.TeamStatus.Waiting,
                    'sportId': 1343201072,
                    'teamAdminUserId': 675780521,
                    'schoolId': 744964398,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Team record.

        Parameters
        ----------
        where
            Team filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The deleted Team record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().delete(
            where={
                'id': 1969681615,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Team record.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().find_unique(
            where={
                'id': 1116175964,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Team record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().find_unique_or_raise(
            where={
                'id': 861472101,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Team records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N results
        where
            Team filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Team]
            The list of all Team records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Team records
        teams = await Team.prisma().find_many(take=10)

        # find the first 5 Team records ordered by the status field
        teams = await Team.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Team record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the createdAt field
        team = await Team.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Team record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the sportId field
        team = await Team.prisma().find_first_or_raise(
            skip=1,
            order={
                'sportId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TeamUpdateInput,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Team record.

        Parameters
        ----------
        data
            Team record data specifying what to update
        where
            Team filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The updated Team record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        team = await Team.prisma().update(
            where={
                'id': 1303003706,
            },
            data={
                # data to update the Team record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TeamWhereUniqueInput,
        data: types.TeamUpsertInput,
        include: Optional[types.TeamInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Team filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created or updated Team record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = await Team.prisma().upsert(
            where={
                'id': 1686638315,
            },
            data={
                'create': {
                    'id': 1686638315,
                    'name': 'dcgchcbbf',
                    'status': enums.TeamStatus.Waiting,
                    'sportId': 1343201072,
                    'teamAdminUserId': 675780521,
                    'schoolId': 744964398,
                },
                'update': {
                    'name': 'dcgchcbbf',
                    'status': enums.TeamStatus.Waiting,
                    'sportId': 1343201072,
                    'teamAdminUserId': 675780521,
                    'schoolId': 744964398,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TeamUpdateManyMutationInput,
        where: types.TeamWhereInput,
    ) -> int:
        """Update multiple Team records

        Parameters
        ----------
        data
            Team data to update the selected Team records to
        where
            Filter to select the Team records to update

        Returns
        -------
        int
            The total number of Team records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Team records
        total = await Team.prisma().update_many(
            data={
                'teamAdminUserId': 2000430152
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = await Team.prisma().count(
            select={
                '_all': True,
                'schoolId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TeamCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> types.TeamCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TeamCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> Union[int, types.TeamCountAggregateOutput]:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = await Team.prisma().count(
            select={
                '_all': True,
                'amountPaidInCents': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TeamWhereInput] = None
    ) -> int:
        """Delete multiple Team records.

        Parameters
        ----------
        where
            Optional Team filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Team records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Team records
        total = await Team.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TeamScalarFieldKeys'],
        *,
        where: Optional['types.TeamWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamAvgAggregateInput'] = None,
        sum: Optional['types.TeamSumAggregateInput'] = None,
        min: Optional['types.TeamMinAggregateInput'] = None,
        max: Optional['types.TeamMaxAggregateInput'] = None,
        having: Optional['types.TeamScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TeamScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamGroupByOutput']:
        """Group Team records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Team fields to group records by
        where
            Team filter to select records
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamGroupByOutput]
            A list of dictionaries representing the Team record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Team records by amountToPayInCents values
        # and count how many records are in each group
        results = await Team.prisma().group_by(
            ['amountToPayInCents'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1868141281,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'bigaiehgcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'beeifcbebf',
                'password': 'bgcigfahea',
                'firstname': 'bcejgaggif',
                'lastname': 'idfjadbcc',
                'mobile': 'hgdhbjhhj',
                'schoolId': 429995104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'bhhfibbigf',
                    'password': 'ijdbeffgg',
                    'firstname': 'jjfeafhfj',
                    'lastname': 'cbachdgfce',
                    'mobile': 'chbfcacbd',
                    'schoolId': 456633834,
                },
                {
                    # data to create a User record
                    'email': 'caficfigfb',
                    'password': 'bfidgijfjc',
                    'firstname': 'ihieecagf',
                    'lastname': 'bghfciaafe',
                    'mobile': 'bgchfhgceh',
                    'schoolId': 2054802212,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 60335757,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 684462146,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 1625503827,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the password field
        users = await User.prisma().find_many(
            take=5,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the firstname field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'firstname': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the lastname field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'lastname': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 521827728,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 1266032265,
            },
            data={
                'create': {
                    'id': 1266032265,
                    'email': 'caficfigfb',
                    'password': 'bfidgijfjc',
                    'firstname': 'ihieecagf',
                    'lastname': 'bghfciaafe',
                    'mobile': 'bgchfhgceh',
                    'schoolId': 2054802212,
                },
                'update': {
                    'email': 'caficfigfb',
                    'password': 'bfidgijfjc',
                    'firstname': 'ihieecagf',
                    'lastname': 'bghfciaafe',
                    'mobile': 'bgchfhgceh',
                    'schoolId': 2054802212,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'mobile': 'jdcfdcgc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'schoolId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by sportAdminId values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['sportAdminId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ParticipantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Participant]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Participant.prisma().query_raw(
            'SELECT * FROM Participant WHERE id = $1',
            2053047983,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Participant
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Participant.prisma().query_first(
            'SELECT * FROM Participant WHERE gender = $1',
            enums.Gender.F,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ParticipantCreateInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> _PrismaModelT:
        """Create a new Participant record.

        Parameters
        ----------
        data
            Participant record data
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The created Participant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Participant record from just the required fields
        participant = await Participant.prisma().create(
            data={
                # data to create a Participant record
                'gender': enums.Gender.F,
                'firstname': 'gifdddbia',
                'lastname': 'bchehecef',
                'email': 'jeijcbhfe',
                'dateOfBirth': datetime.datetime.utcnow(),
                'charteIsValidated': False,
                'chartePassword': 'bcciijbibg',
                'isCaptain': False,
                'schoolId': 1223573862,
                'teamId': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ParticipantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Participant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Participant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Participant.prisma().create_many(
            data=[
                {
                    # data to create a Participant record
                    'gender': enums.Gender.F,
                    'firstname': 'bageiegghg',
                    'lastname': 'faidicegb',
                    'email': 'bacecgfhbe',
                    'dateOfBirth': datetime.datetime.utcnow(),
                    'charteIsValidated': False,
                    'chartePassword': 'biheheiajg',
                    'isCaptain': False,
                    'schoolId': 769267518,
                    'teamId': 820312479,
                },
                {
                    # data to create a Participant record
                    'gender': enums.Gender.F,
                    'firstname': 'jchciaee',
                    'lastname': 'deeificjd',
                    'email': 'bbcbhebbda',
                    'dateOfBirth': datetime.datetime.utcnow(),
                    'charteIsValidated': False,
                    'chartePassword': 'caifcbgii',
                    'isCaptain': False,
                    'schoolId': 1660932118,
                    'teamId': 525761943,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Participant record.

        Parameters
        ----------
        where
            Participant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The deleted Participant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = await Participant.prisma().delete(
            where={
                'id': 736209796,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Participant record.

        Parameters
        ----------
        where
            Participant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The found Participant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = await Participant.prisma().find_unique(
            where={
                'id': 493907821,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Participant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Participant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The found Participant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = await Participant.prisma().find_unique_or_raise(
            where={
                'id': 639686562,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
        include: Optional[types.ParticipantInclude] = None,
        order: Optional[Union[types.ParticipantOrderByInput, List[types.ParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ParticipantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Participant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Participant records returned
        skip
            Ignore the first N results
        where
            Participant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Participant model
        order
            Order the returned Participant records by any field
        distinct
            Filter Participant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Participant]
            The list of all Participant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Participant records
        participants = await Participant.prisma().find_many(take=10)

        # find the first 5 Participant records ordered by the firstname field
        participants = await Participant.prisma().find_many(
            take=5,
            order={
                'firstname': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
        include: Optional[types.ParticipantInclude] = None,
        order: Optional[Union[types.ParticipantOrderByInput, List[types.ParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ParticipantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Participant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Participant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Participant model
        order
            Order the returned Participant records by any field
        distinct
            Filter Participant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Participant
            The first Participant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Participant record ordered by the lastname field
        participant = await Participant.prisma().find_first(
            skip=1,
            order={
                'lastname': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
        include: Optional[types.ParticipantInclude] = None,
        order: Optional[Union[types.ParticipantOrderByInput, List[types.ParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ParticipantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Participant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Participant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Participant model
        order
            Order the returned Participant records by any field
        distinct
            Filter Participant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Participant
            The first Participant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Participant record ordered by the email field
        participant = await Participant.prisma().find_first_or_raise(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ParticipantUpdateInput,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Participant record.

        Parameters
        ----------
        data
            Participant record data specifying what to update
        where
            Participant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The updated Participant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        participant = await Participant.prisma().update(
            where={
                'id': 654007347,
            },
            data={
                # data to update the Participant record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ParticipantWhereUniqueInput,
        data: types.ParticipantUpsertInput,
        include: Optional[types.ParticipantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Participant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The created or updated Participant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = await Participant.prisma().upsert(
            where={
                'id': 1905261552,
            },
            data={
                'create': {
                    'id': 1905261552,
                    'gender': enums.Gender.F,
                    'firstname': 'jchciaee',
                    'lastname': 'deeificjd',
                    'email': 'bbcbhebbda',
                    'dateOfBirth': datetime.datetime.utcnow(),
                    'charteIsValidated': False,
                    'chartePassword': 'caifcbgii',
                    'isCaptain': False,
                    'schoolId': 1660932118,
                    'teamId': 525761943,
                },
                'update': {
                    'gender': enums.Gender.F,
                    'firstname': 'jchciaee',
                    'lastname': 'deeificjd',
                    'email': 'bbcbhebbda',
                    'dateOfBirth': datetime.datetime.utcnow(),
                    'charteIsValidated': False,
                    'chartePassword': 'caifcbgii',
                    'isCaptain': False,
                    'schoolId': 1660932118,
                    'teamId': 525761943,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ParticipantUpdateManyMutationInput,
        where: types.ParticipantWhereInput,
    ) -> int:
        """Update multiple Participant records

        Parameters
        ----------
        data
            Participant data to update the selected Participant records to
        where
            Filter to select the Participant records to update

        Returns
        -------
        int
            The total number of Participant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Participant records
        total = await Participant.prisma().update_many(
            data={
                'dateOfBirth': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Participant records present in the database

        Parameters
        ----------
        select
            Select the Participant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Participant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Participant.prisma().count()

        # results: prisma.types.ParticipantCountAggregateOutput
        results = await Participant.prisma().count(
            select={
                '_all': True,
                'charteIsValidated': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ParticipantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
    ) -> types.ParticipantCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ParticipantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
    ) -> Union[int, types.ParticipantCountAggregateOutput]:
        """Count the number of Participant records present in the database

        Parameters
        ----------
        select
            Select the Participant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Participant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Participant.prisma().count()

        # results: prisma.types.ParticipantCountAggregateOutput
        results = await Participant.prisma().count(
            select={
                '_all': True,
                'chartePassword': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ParticipantCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ParticipantWhereInput] = None
    ) -> int:
        """Delete multiple Participant records.

        Parameters
        ----------
        where
            Optional Participant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Participant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Participant records
        total = await Participant.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ParticipantScalarFieldKeys'],
        *,
        where: Optional['types.ParticipantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ParticipantAvgAggregateInput'] = None,
        sum: Optional['types.ParticipantSumAggregateInput'] = None,
        min: Optional['types.ParticipantMinAggregateInput'] = None,
        max: Optional['types.ParticipantMaxAggregateInput'] = None,
        having: Optional['types.ParticipantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ParticipantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ParticipantScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ParticipantScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ParticipantGroupByOutput']:
        """Group Participant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Participant fields to group records by
        where
            Participant filter to select records
        take
            Limit the maximum number of Participant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ParticipantGroupByOutput]
            A list of dictionaries representing the Participant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Participant records by createdAt values
        # and count how many records are in each group
        results = await Participant.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SchoolActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.School]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await School.prisma().query_raw(
            'SELECT * FROM School WHERE id = $1',
            78746985,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.School
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await School.prisma().query_first(
            'SELECT * FROM School WHERE name = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SchoolCreateInput,
        include: Optional[types.SchoolInclude] = None
    ) -> _PrismaModelT:
        """Create a new School record.

        Parameters
        ----------
        data
            School record data
        include
            Specifies which relations should be loaded on the returned School model

        Returns
        -------
        prisma.models.School
            The created School record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a School record from just the required fields
        school = await School.prisma().create(
            data={
                # data to create a School record
                'name': 'ifgaaagff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SchoolCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple School records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of School record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await School.prisma().create_many(
            data=[
                {
                    # data to create a School record
                    'name': 'befcddgjce',
                },
                {
                    # data to create a School record
                    'name': 'bfhdbjjgfd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SchoolWhereUniqueInput,
        include: Optional[types.SchoolInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single School record.

        Parameters
        ----------
        where
            School filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned School model

        Returns
        -------
        prisma.models.School
            The deleted School record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        school = await School.prisma().delete(
            where={
                'id': 2013903098,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SchoolWhereUniqueInput,
        include: Optional[types.SchoolInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique School record.

        Parameters
        ----------
        where
            School filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned School model

        Returns
        -------
        prisma.models.School
            The found School record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        school = await School.prisma().find_unique(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SchoolWhereUniqueInput,
        include: Optional[types.SchoolInclude] = None
    ) -> _PrismaModelT:
        """Find a unique School record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            School filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned School model

        Returns
        -------
        prisma.models.School
            The found School record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        school = await School.prisma().find_unique_or_raise(
            where={
                'id': 1800624392,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SchoolWhereInput] = None,
        cursor: Optional[types.SchoolWhereUniqueInput] = None,
        include: Optional[types.SchoolInclude] = None,
        order: Optional[Union[types.SchoolOrderByInput, List[types.SchoolOrderByInput]]] = None,
        distinct: Optional[List[types.SchoolScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple School records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of School records returned
        skip
            Ignore the first N results
        where
            School filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned School model
        order
            Order the returned School records by any field
        distinct
            Filter School records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.School]
            The list of all School records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 School records
        schools = await School.prisma().find_many(take=10)

        # find the first 5 School records ordered by the id field
        schools = await School.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SchoolWhereInput] = None,
        cursor: Optional[types.SchoolWhereUniqueInput] = None,
        include: Optional[types.SchoolInclude] = None,
        order: Optional[Union[types.SchoolOrderByInput, List[types.SchoolOrderByInput]]] = None,
        distinct: Optional[List[types.SchoolScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single School record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            School filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned School model
        order
            Order the returned School records by any field
        distinct
            Filter School records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.School
            The first School record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second School record ordered by the name field
        school = await School.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SchoolWhereInput] = None,
        cursor: Optional[types.SchoolWhereUniqueInput] = None,
        include: Optional[types.SchoolInclude] = None,
        order: Optional[Union[types.SchoolOrderByInput, List[types.SchoolOrderByInput]]] = None,
        distinct: Optional[List[types.SchoolScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single School record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            School filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned School model
        order
            Order the returned School records by any field
        distinct
            Filter School records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.School
            The first School record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second School record ordered by the id field
        school = await School.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SchoolUpdateInput,
        where: types.SchoolWhereUniqueInput,
        include: Optional[types.SchoolInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single School record.

        Parameters
        ----------
        data
            School record data specifying what to update
        where
            School filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned School model

        Returns
        -------
        prisma.models.School
            The updated School record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        school = await School.prisma().update(
            where={
                'id': 2077067425,
            },
            data={
                # data to update the School record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SchoolWhereUniqueInput,
        data: types.SchoolUpsertInput,
        include: Optional[types.SchoolInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            School filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned School model

        Returns
        -------
        prisma.models.School
            The created or updated School record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        school = await School.prisma().upsert(
            where={
                'id': 1672112838,
            },
            data={
                'create': {
                    'id': 1672112838,
                    'name': 'bfhdbjjgfd',
                },
                'update': {
                    'name': 'bfhdbjjgfd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SchoolUpdateManyMutationInput,
        where: types.SchoolWhereInput,
    ) -> int:
        """Update multiple School records

        Parameters
        ----------
        data
            School data to update the selected School records to
        where
            Filter to select the School records to update

        Returns
        -------
        int
            The total number of School records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all School records
        total = await School.prisma().update_many(
            data={
                'name': 'jcgghhgdj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SchoolWhereInput] = None,
        cursor: Optional[types.SchoolWhereUniqueInput] = None,
    ) -> int:
        """Count the number of School records present in the database

        Parameters
        ----------
        select
            Select the School fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            School filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SchoolCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await School.prisma().count()

        # results: prisma.types.SchoolCountAggregateOutput
        results = await School.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SchoolCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SchoolWhereInput] = None,
        cursor: Optional[types.SchoolWhereUniqueInput] = None,
    ) -> types.SchoolCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SchoolCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SchoolWhereInput] = None,
        cursor: Optional[types.SchoolWhereUniqueInput] = None,
    ) -> Union[int, types.SchoolCountAggregateOutput]:
        """Count the number of School records present in the database

        Parameters
        ----------
        select
            Select the School fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            School filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SchoolCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await School.prisma().count()

        # results: prisma.types.SchoolCountAggregateOutput
        results = await School.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SchoolCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SchoolWhereInput] = None
    ) -> int:
        """Delete multiple School records.

        Parameters
        ----------
        where
            Optional School filter to find the records to be deleted

        Returns
        -------
        int
            The total number of School records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all School records
        total = await School.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SchoolScalarFieldKeys'],
        *,
        where: Optional['types.SchoolWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SchoolAvgAggregateInput'] = None,
        sum: Optional['types.SchoolSumAggregateInput'] = None,
        min: Optional['types.SchoolMinAggregateInput'] = None,
        max: Optional['types.SchoolMaxAggregateInput'] = None,
        having: Optional['types.SchoolScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SchoolCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SchoolScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SchoolScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SchoolGroupByOutput']:
        """Group School records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar School fields to group records by
        where
            School filter to select records
        take
            Limit the maximum number of School records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SchoolGroupByOutput]
            A list of dictionaries representing the School record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group School records by id values
        # and count how many records are in each group
        results = await School.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GeneralConfigActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GeneralConfig]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GeneralConfig.prisma().query_raw(
            'SELECT * FROM GeneralConfig WHERE id = $1',
            1447624116,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GeneralConfig
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GeneralConfig.prisma().query_first(
            'SELECT * FROM GeneralConfig WHERE editionYear = $1',
            1738083805,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GeneralConfigCreateInput,
        include: Optional[types.GeneralConfigInclude] = None
    ) -> _PrismaModelT:
        """Create a new GeneralConfig record.

        Parameters
        ----------
        data
            GeneralConfig record data
        include
            Specifies which relations should be loaded on the returned GeneralConfig model

        Returns
        -------
        prisma.models.GeneralConfig
            The created GeneralConfig record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GeneralConfig record from just the required fields
        generalconfig = await GeneralConfig.prisma().create(
            data={
                # data to create a GeneralConfig record
                'editionYear': 340946258,
                'isRegistrationOpen': False,
                'isPaymentOpen': True,
                'expectedRegistrationDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GeneralConfigCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GeneralConfig records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GeneralConfig record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GeneralConfig.prisma().create_many(
            data=[
                {
                    # data to create a GeneralConfig record
                    'editionYear': 1855826649,
                    'isRegistrationOpen': True,
                    'isPaymentOpen': False,
                    'expectedRegistrationDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a GeneralConfig record
                    'editionYear': 300568396,
                    'isRegistrationOpen': False,
                    'isPaymentOpen': True,
                    'expectedRegistrationDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GeneralConfigWhereUniqueInput,
        include: Optional[types.GeneralConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GeneralConfig record.

        Parameters
        ----------
        where
            GeneralConfig filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GeneralConfig model

        Returns
        -------
        prisma.models.GeneralConfig
            The deleted GeneralConfig record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generalconfig = await GeneralConfig.prisma().delete(
            where={
                'id': 470157467,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GeneralConfigWhereUniqueInput,
        include: Optional[types.GeneralConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GeneralConfig record.

        Parameters
        ----------
        where
            GeneralConfig filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneralConfig model

        Returns
        -------
        prisma.models.GeneralConfig
            The found GeneralConfig record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generalconfig = await GeneralConfig.prisma().find_unique(
            where={
                'id': 1209209912,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GeneralConfigWhereUniqueInput,
        include: Optional[types.GeneralConfigInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GeneralConfig record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GeneralConfig filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneralConfig model

        Returns
        -------
        prisma.models.GeneralConfig
            The found GeneralConfig record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generalconfig = await GeneralConfig.prisma().find_unique_or_raise(
            where={
                'id': 1536744465,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneralConfigWhereInput] = None,
        cursor: Optional[types.GeneralConfigWhereUniqueInput] = None,
        include: Optional[types.GeneralConfigInclude] = None,
        order: Optional[Union[types.GeneralConfigOrderByInput, List[types.GeneralConfigOrderByInput]]] = None,
        distinct: Optional[List[types.GeneralConfigScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GeneralConfig records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GeneralConfig records returned
        skip
            Ignore the first N results
        where
            GeneralConfig filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneralConfig model
        order
            Order the returned GeneralConfig records by any field
        distinct
            Filter GeneralConfig records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GeneralConfig]
            The list of all GeneralConfig records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GeneralConfig records
        generalconfigs = await GeneralConfig.prisma().find_many(take=10)

        # find the first 5 GeneralConfig records ordered by the isRegistrationOpen field
        generalconfigs = await GeneralConfig.prisma().find_many(
            take=5,
            order={
                'isRegistrationOpen': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneralConfigWhereInput] = None,
        cursor: Optional[types.GeneralConfigWhereUniqueInput] = None,
        include: Optional[types.GeneralConfigInclude] = None,
        order: Optional[Union[types.GeneralConfigOrderByInput, List[types.GeneralConfigOrderByInput]]] = None,
        distinct: Optional[List[types.GeneralConfigScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GeneralConfig record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneralConfig filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneralConfig model
        order
            Order the returned GeneralConfig records by any field
        distinct
            Filter GeneralConfig records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneralConfig
            The first GeneralConfig record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneralConfig record ordered by the isPaymentOpen field
        generalconfig = await GeneralConfig.prisma().find_first(
            skip=1,
            order={
                'isPaymentOpen': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneralConfigWhereInput] = None,
        cursor: Optional[types.GeneralConfigWhereUniqueInput] = None,
        include: Optional[types.GeneralConfigInclude] = None,
        order: Optional[Union[types.GeneralConfigOrderByInput, List[types.GeneralConfigOrderByInput]]] = None,
        distinct: Optional[List[types.GeneralConfigScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GeneralConfig record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneralConfig filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneralConfig model
        order
            Order the returned GeneralConfig records by any field
        distinct
            Filter GeneralConfig records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneralConfig
            The first GeneralConfig record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneralConfig record ordered by the canSendEmails field
        generalconfig = await GeneralConfig.prisma().find_first_or_raise(
            skip=1,
            order={
                'canSendEmails': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GeneralConfigUpdateInput,
        where: types.GeneralConfigWhereUniqueInput,
        include: Optional[types.GeneralConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GeneralConfig record.

        Parameters
        ----------
        data
            GeneralConfig record data specifying what to update
        where
            GeneralConfig filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GeneralConfig model

        Returns
        -------
        prisma.models.GeneralConfig
            The updated GeneralConfig record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        generalconfig = await GeneralConfig.prisma().update(
            where={
                'id': 424218998,
            },
            data={
                # data to update the GeneralConfig record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GeneralConfigWhereUniqueInput,
        data: types.GeneralConfigUpsertInput,
        include: Optional[types.GeneralConfigInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GeneralConfig filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GeneralConfig model

        Returns
        -------
        prisma.models.GeneralConfig
            The created or updated GeneralConfig record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generalconfig = await GeneralConfig.prisma().upsert(
            where={
                'id': 2125632375,
            },
            data={
                'create': {
                    'id': 2125632375,
                    'editionYear': 300568396,
                    'isRegistrationOpen': False,
                    'isPaymentOpen': True,
                    'expectedRegistrationDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'editionYear': 300568396,
                    'isRegistrationOpen': False,
                    'isPaymentOpen': True,
                    'expectedRegistrationDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GeneralConfigUpdateManyMutationInput,
        where: types.GeneralConfigWhereInput,
    ) -> int:
        """Update multiple GeneralConfig records

        Parameters
        ----------
        data
            GeneralConfig data to update the selected GeneralConfig records to
        where
            Filter to select the GeneralConfig records to update

        Returns
        -------
        int
            The total number of GeneralConfig records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GeneralConfig records
        total = await GeneralConfig.prisma().update_many(
            data={
                'expectedRegistrationDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneralConfigWhereInput] = None,
        cursor: Optional[types.GeneralConfigWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GeneralConfig records present in the database

        Parameters
        ----------
        select
            Select the GeneralConfig fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneralConfig filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneralConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneralConfig.prisma().count()

        # results: prisma.types.GeneralConfigCountAggregateOutput
        results = await GeneralConfig.prisma().count(
            select={
                '_all': True,
                'mailClient': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GeneralConfigCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneralConfigWhereInput] = None,
        cursor: Optional[types.GeneralConfigWhereUniqueInput] = None,
    ) -> types.GeneralConfigCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GeneralConfigCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneralConfigWhereInput] = None,
        cursor: Optional[types.GeneralConfigWhereUniqueInput] = None,
    ) -> Union[int, types.GeneralConfigCountAggregateOutput]:
        """Count the number of GeneralConfig records present in the database

        Parameters
        ----------
        select
            Select the GeneralConfig fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneralConfig filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneralConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneralConfig.prisma().count()

        # results: prisma.types.GeneralConfigCountAggregateOutput
        results = await GeneralConfig.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GeneralConfigCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GeneralConfigWhereInput] = None
    ) -> int:
        """Delete multiple GeneralConfig records.

        Parameters
        ----------
        where
            Optional GeneralConfig filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GeneralConfig records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GeneralConfig records
        total = await GeneralConfig.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GeneralConfigScalarFieldKeys'],
        *,
        where: Optional['types.GeneralConfigWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GeneralConfigAvgAggregateInput'] = None,
        sum: Optional['types.GeneralConfigSumAggregateInput'] = None,
        min: Optional['types.GeneralConfigMinAggregateInput'] = None,
        max: Optional['types.GeneralConfigMaxAggregateInput'] = None,
        having: Optional['types.GeneralConfigScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GeneralConfigCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GeneralConfigScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GeneralConfigScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GeneralConfigGroupByOutput']:
        """Group GeneralConfig records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GeneralConfig fields to group records by
        where
            GeneralConfig filter to select records
        take
            Limit the maximum number of GeneralConfig records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GeneralConfigGroupByOutput]
            A list of dictionaries representing the GeneralConfig record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GeneralConfig records by editionYear values
        # and count how many records are in each group
        results = await GeneralConfig.prisma().group_by(
            ['editionYear'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PaymentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Payment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Payment.prisma().query_raw(
            'SELECT * FROM Payment WHERE id = $1',
            536951780,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Payment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Payment.prisma().query_first(
            'SELECT * FROM Payment WHERE amountInCents = $1',
            924723277,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PaymentCreateInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Payment record.

        Parameters
        ----------
        data
            Payment record data
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created Payment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Payment record from just the required fields
        payment = await Payment.prisma().create(
            data={
                # data to create a Payment record
                'amountInCents': 1621937922,
                'userId': 1848832019,
                'teamId': 1921528400,
                'paymentStatus': enums.PaymentStatus.Pending,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PaymentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Payment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Payment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Payment.prisma().create_many(
            data=[
                {
                    # data to create a Payment record
                    'amountInCents': 2100427849,
                    'userId': 849140046,
                    'teamId': 928152175,
                    'paymentStatus': enums.PaymentStatus.Pending,
                },
                {
                    # data to create a Payment record
                    'amountInCents': 273032060,
                    'userId': 982848517,
                    'teamId': 510737498,
                    'paymentStatus': enums.PaymentStatus.Pending,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Payment record.

        Parameters
        ----------
        where
            Payment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The deleted Payment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().delete(
            where={
                'id': 2117488267,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Payment record.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique(
            where={
                'id': 1401944936,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Payment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique_or_raise(
            where={
                'id': 1297607553,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Payment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N results
        where
            Payment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Payment]
            The list of all Payment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Payment records
        payments = await Payment.prisma().find_many(take=10)

        # find the first 5 Payment records ordered by the createdAt field
        payments = await Payment.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Payment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the userId field
        payment = await Payment.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Payment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the teamId field
        payment = await Payment.prisma().find_first_or_raise(
            skip=1,
            order={
                'teamId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PaymentUpdateInput,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Payment record.

        Parameters
        ----------
        data
            Payment record data specifying what to update
        where
            Payment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The updated Payment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        payment = await Payment.prisma().update(
            where={
                'id': 519488550,
            },
            data={
                # data to update the Payment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PaymentWhereUniqueInput,
        data: types.PaymentUpsertInput,
        include: Optional[types.PaymentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Payment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created or updated Payment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().upsert(
            where={
                'id': 976832615,
            },
            data={
                'create': {
                    'id': 976832615,
                    'amountInCents': 273032060,
                    'userId': 982848517,
                    'teamId': 510737498,
                    'paymentStatus': enums.PaymentStatus.Pending,
                },
                'update': {
                    'amountInCents': 273032060,
                    'userId': 982848517,
                    'teamId': 510737498,
                    'paymentStatus': enums.PaymentStatus.Pending,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PaymentUpdateManyMutationInput,
        where: types.PaymentWhereInput,
    ) -> int:
        """Update multiple Payment records

        Parameters
        ----------
        data
            Payment data to update the selected Payment records to
        where
            Filter to select the Payment records to update

        Returns
        -------
        int
            The total number of Payment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Payment records
        total = await Payment.prisma().update_many(
            data={
                'paymentStatus': enums.PaymentStatus.Pending
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'requestId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PaymentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> types.PaymentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PaymentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> Union[int, types.PaymentCountAggregateOutput]:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'requestUuid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PaymentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PaymentWhereInput] = None
    ) -> int:
        """Delete multiple Payment records.

        Parameters
        ----------
        where
            Optional Payment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Payment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Payment records
        total = await Payment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PaymentScalarFieldKeys'],
        *,
        where: Optional['types.PaymentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PaymentAvgAggregateInput'] = None,
        sum: Optional['types.PaymentSumAggregateInput'] = None,
        min: Optional['types.PaymentMinAggregateInput'] = None,
        max: Optional['types.PaymentMaxAggregateInput'] = None,
        having: Optional['types.PaymentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PaymentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PaymentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PaymentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PaymentGroupByOutput']:
        """Group Payment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Payment fields to group records by
        where
            Payment filter to select records
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PaymentGroupByOutput]
            A list of dictionaries representing the Payment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Payment records by id values
        # and count how many records are in each group
        results = await Payment.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models